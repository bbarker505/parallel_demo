{
    "collab_server" : "",
    "contents" : "#!/usr/bin/Rscript\n#.libPaths(\"/usr/lib64/R/library/\")\n# Log of recent edits\n# \n# 7/24/20: Replaced \"mclapply\" function with a foreach loop because mclapply\n#  cannot be used on Windows system; improved method for registering cluster so\n#  that it is based on number of cores in the computer or server being used.\n# 7/1/20: Added \"StageCount\" raster and map outputs, added map outputs for \n# current day, improved map legends, added more input param checks \n#   TO DO: \"odd_map_gen\" param doesn't work well at small scales becuase \n#   certain gens may be missing. Maybe address in future versions of DDRP.  \n# On 4/24/20: Changed the parameter name \"chill stress\" to \"cold stress\"\n# 3/30/20: fixed typo/missing object in log file text for Adult by Gen\n# 2/17/20: major overhaul of NumGen weighting and Adult by Lifestage analyses. \n# Experimenting showed that saving large raster bricks to disk may slightly\n# improve run times (compared to holding them in memory). Also removed FORK\n# option in RegCluster because was causing crashes on Hopper.\n# 2/7/20: modified code for Adult by Gen summary maps so that temp rasters\n# are saved to file instead of being held in memory; was resulting in \"can not\n# open connection errors\" and subsequent run crashes\n# 1/28/20: detect CRS from template data, not hard-code it\n# 1/23/20: finished fixing bugs w/ closing connections for clusters, and\n# resolving issues with memory\n# 1/17/20: inc. no. of gens for mapping; increase memory w/ FORK etc.\n# 1/3/20: fixed bug that was deleting output raster files\n# 12/16/19: renamed file names and uploaded to GitHub\n# 11/26/19: fixed bug w/ loading 30 yr climate normals\n\n# DDRP v2\noptions(echo = FALSE)\n\n# Load the required packages\npkgs <- c(\"doParallel\", \"dplyr\", \"foreach\", \"ggplot2\", \"ggthemes\", \n          \"lubridate\", \"mapdata\", \"mgsub\", \"optparse\", \"parallel\",\n          \"purrr\", \"RColorBrewer\", \"rgdal\", \"raster\", \"readr\", \"sp\", \"stringr\", \n          \"tidyr\", \"tictoc\", \"tools\", \"toOrdinal\")\nld_pkgs <- lapply(pkgs, library, \n                  lib.loc = \"/usr/lib64/R/library/\", character.only = TRUE)\n\n# Load collection of functions for this model\nsource(\"/usr/local/dds/DDRP_B1/DDRP_v2_funcs.R\")\n\n# Bring in states feature for summary maps (PNG files)\n# Requires these libraries: \"mapdata\" and \"maptools\"\ncat(\"\\n\\nDownloading US states feature\\n\")\nstates <- map_data(\"state\")\n\n# Start timing the model run\ntic(\"Total run time\")\n\n################################################################################\n########                  Header Documentation Section             #############\n#  Cohorts DDRP: Degree-Day, establishment Risk, and Pest event mapping system #\n########  By Brittany Barker, Len Coop, Gericke Cook, Dan Upper, and ###########\n########  Tyson Wepprich for APHIS PPQ and IPM needs ###########################\n################################################################################\n\n# DDRP v2 is an update from the previous version of DDRP \n# (v24proDDRP_B1.R = DDRP_v1) that includes:\n# 1. The ability to accomodate multiple population cohorts, in which a user-\n#    defined number of cohorts emerges from the overwintering stage at different\n#    times, such that a population in any given area could contain a mix of\n#    indidivuals in different life stages and generations\n# 2. Parallel processing, in which several processes are run in parallel in \n#    order to speed up the model run (e.g., temperature raster cropping, \n#    daily loop runs for multiple CONUS tiles and cohorts, production of raster \n#    and summary map outputs)\n# 3. A new summary map type - Lifestage by Generation, which shows the relative\n#    population size of a specific life stage (currently only adults) for each \n#    distinct generation (e.g., Gen1 adults, Gen 2 adults...)\n# 4. Other more minor improvements/features are included as well, such as: \n#       a) the ability for summary maps to show a specific state or region of \n#       interest. The previous version of DDRP can only show CONUS.\n#       b) the ability to generate summary maps for odd generations only. This \n#       may be useful if there is a lot of spatial overlap between generations, \n#       which would make it difficult to see where the boundaries of Gen1 and\n#       Gen 3 are, for example. \n#       c) the use of a command line parser that includes parameter abbrevs.\n#       d) the ability to include or exclude leap day in the model run\n#       \n#     \n# (1). PARAM HANDLING -----\n#### * Process command line args ####\n#### # Uses \"optparse\" package, a command line parser similar to Python's\noption_list <- list(\n  make_option(c(\"--spp\"), action = \"store\", type = \"character\", \n              default = NA, help = \"species parameter file name\"),\n  make_option(c(\"--forecast_data\"), action = \"store\", type = \"character\", \n              default = NA, help = \"weather data for forecast\"),\n  make_option(c(\"--start_year\"),  action = \"store\", type = \"character\", \n              default = NA, help = \"start year\"),\n  make_option(c(\"--start_doy\"), action = \"store\", type = \"integer\", \n              default = NA, help = \"start day of year\"),\n  make_option(c(\"--end_doy\"),  action = \"store\", type = \"integer\",\n              default = NA, help = \"end day of year\"),\n  make_option(c(\"--keep_leap\"), action = \"store\", type = \"integer\", \n              default = NA, help = \"should leap day be kept? 0=no, 1=yes\"),\n  make_option(c(\"--region_param\"), type = \"character\", action = \"store\", \n              default = NA, help = \"study region: CONUS, EAST, WEST, or \n              state (2-letter abbr.)\"),\n  make_option(c(\"--exclusions_stressunits\"), type = \"integer\", action = \"store\",\n              default = NA, help = \"0 = off, 1 = on\"),\n  make_option(c(\"--pems\"), type = \"integer\", action = \"store\", \n              default = NA, help = \"0 = off, 1 = on\"),\n  make_option(c(\"--mapA\"), type = \"integer\", action = \"store\", \n              default = NA, help = \"0 = off, 1 = on\"),\n  make_option(c(\"--mapE\"), type = \"integer\", action = \"store\", \n              default = NA, help = \"0 = off, 1 = on\"),\n  make_option(c(\"--mapL\"), type = \"integer\", action = \"store\", \n              default = NA, help = \"0 = off, 1 = on\"),\n  make_option(c(\"--mapP\"), type = \"integer\", action = \"store\", \n              default = NA, help = \"0 = off, 1 = on\"),\n  make_option(c(\"--out_dir\"), type = \"character\", action = \"store\", \n              default = NA, help = \"name of out directory\"),\n  make_option(c(\"--out_option\"), type = \"integer\", action = \"store\", \n              default = NA, help = \"sampling frequency: 1 = 30 days; \n              2 = 14 days; 3 = 10 days; 4 = 7 days; 5 = 2 days; 6 = 1 day\"),\n  make_option(c(\"--ncohort\"), type = \"integer\", action = \"store\", \n              default = NA, help = \"number of cohorts\"),\n  make_option(c(\"--odd_gen_map\"), type = \"numeric\", action = \"store\", \n              default = NA, help = \"0 = off, 1 = on\")\n)\n\n# Read in commands \n# If command line isn't used, then opts list elements will be NA\nopts <- parse_args(OptionParser(option_list = option_list))\nif (!is.na(opts[1])) {\n  spp <- opts$spp\n  forecast_data <- opts$forecast_data\n  start_year <- opts$start_year\n  start_doy <- opts$start_doy\n  end_doy <- opts$end_doy\n  keep_leap <- opts$keep_leap\n  region_param <- opts$region_param\n  exclusions_stressunits <- opts$exclusions_stressunits\n  pems <- opts$pems\n  mapA <- opts$mapA\n  mapE <- opts$mapE\n  mapL <- opts$mapL\n  mapP <- opts$mapP\n  out_dir <- opts$out_dir\n  out_option <- opts$out_option\n  ncohort <- opts$ncohort\n  odd_gen_map <- opts$odd_gen_map\n} else {\n  #### * Default values for params, if not provided in command line ####\n  spp           <- \"LBAM\" # Default species to use\n  forecast_data <- \"PRISM\" # Forecast data to use (PRISM or NMME)\n  start_year    <- \"2012\" # Year to use\n  start_doy     <- 1 # Start day of year          \n  end_doy       <- 365 # End day of year - need 365 if voltinism map \n  keep_leap     <- 1 # Should leap day be kept?\n  region_param  <- \"CONUS\" # Region [CONUS, EAST, WEST, or state (2-letter abbr.)]\n  exclusions_stressunits    <- 1 # Turn on/off climate stress unit exclusions\n  pems          <- 0 # Turn on/off pest event maps\n  mapA          <- 1 # Make maps for adult stage\n  mapE          <- 1 # Make maps for egg stage\n  mapL          <- 0 # Make maps for larval stage\n  mapP          <- 0 # Make maps for pupal stage\n  out_dir       <- \"LBAM_test\" # Output dir\n  out_option    <- 1 # Sampling frequency\n  ncohort       <- 7 # Number of cohorts to approximate end of OW stage\n  odd_gen_map   <- 0 # Create summary plots for odd gens only (gen1, gen3, ..)\n}\n\n# (2). DIRECTORY INIT ------\n\n#### * Param inputs - species params; thresholds, weather, etc. ####\nparams_dir <- \"/usr/local/dds/DDRP_B1/spp_params/\"\n\n#### * Weather inputs and outputs - climate data w/subdirs 4-digit year ####\n# If outdir has 2 consec. numbers, assume webuser; otherwise just use base dir\n#if (grepl(\"16\", start_year, perl = TRUE)) {\n#  base_dir <- \"/mnt/ssd1/PRISM/\"\n#} else {\n  base_dir <- \"/data/PRISM/\"\n#}\nprism_dir <- paste0(base_dir, start_year)\n\ncat(\"\\nBASE DIR: \", base_dir, \"\\n\")\ncat(\"\\nWORKING DIR: \", prism_dir, \"\\n\")\n\n#### * Output directory, log file, and error message file ####\n# MUST remove .tif files or script will crash during processing because it will \n# try to analyze previously processed results. \n\n#output_dir <- paste0(\"/home/httpd/html/CAPS/\", spp, \"_cohorts\")\noutput_dir <- paste0(\"/usr/local/dds/DDRP_B1/DDRP_results/\", out_dir)\n\n# Remove all files if output_dir exists, or else create output_dir\nif (file.exists(output_dir)) {\n  unlink(paste0(output_dir, \"/*\"), recursive = TRUE, force = TRUE)\n  cat(\"\\n\", str_wrap(paste0(\"EXISTING OUTPUT DIR: \", output_dir, \n                     \"; removing all files\\n\"), width = 80), sep = \"\") \n} else {\n  dir.create(output_dir)\n  cat(\"NEW OUTPUT DIR:\", output_dir, \"\\n\")\n}\n\n# Push out a rlogging file with all main messages in model\n# Put all log, message, and metadata files in a separate folder\nsetwd(output_dir)\ndir.create(\"Logs_metadata\")\nModel_rlogging <- sprintf(\"%s%s\", \"./\", \"/Logs_metadata/Model_rlogging.txt\")\n\n# Make header for logging file\ncat(paste0(rep(\"#\", 36), collapse = \"\"), \"\\n\", \n    \"### Log file for DDRP v2 ###\\n\", \n    paste0(rep(\"#\", 36), collapse = \"\"), \"\\n\\n\", sep = \"\", \n    file = Model_rlogging)\n\n# Record PRISM and output dir\ncat(\"BASE DIR: \", base_dir, \"\\n\", file = Model_rlogging, append = TRUE)\ncat(\"WORKING DIR: \", prism_dir, \"\\n\", file = Model_rlogging, append = TRUE)\ncat(str_wrap(paste0(\"EXISTING OUTPUT DIR: \", output_dir, \n    \"; removing all files\"), width = 80), \"\\n\\n\", sep = \"\", \n    file = Model_rlogging, append = TRUE)\n\n# Push out a message file with all R error messages\nmsg <- file(paste0(output_dir, \"/Logs_metadata/rmessages.txt\"), open = \"wt\")\nsink(msg, type = \"message\")\n\n# (3). PARAMETER AND SETTINGS SETUP ----- \ncat(\"PARAMETER AND SETTINGS SETUP: getting parameters to use in model\\n\", \n    file = Model_rlogging, append = TRUE)\ncat(\"\\n\\nPARAMETER AND SETTINGS SETUP: getting parameters to use in model\\n\")\n\n# Read from source param files in ./spp_params/SPP.params\nparam_file <- sprintf(\"%s%s\", spp, \".params\")\nspp <- gsub(\".params\", \"\", param_file) # Get species abbr.\nspecies_params <- sprintf(\"%s%s\", params_dir, param_file) # Location of file\n\nif (file.exists(species_params)) {\n  cat(\"Species params: \", species_params, \"\\n\", file = Model_rlogging, \n      append = TRUE)\n  source(species_params) # Read in species parameters\n  cat(\"Reading params for species: \", spp, \" Fullname: \", fullname, \"\\n\", \n      file = Model_rlogging, append = TRUE)\n  cat(\"\\nReading params for species: \", spp, \" Fullname: \", fullname, \"\\n\")\n} else {\n  cat(\"Param file: \", species_params, \"...not found; exiting program\\n\", \n      file = Model_rlogging, append = TRUE)\n  cat(\"\\nParam file: \", species_params, \"...not found; exiting program\\n\")\n  q()  # No reason to keep going without any params\n}\n\n# Change year to numeric if it's a specific year\n# If using climate normals, there may be letters in folder name\nif (!grepl(\"[A-z]\", start_year)) {\n  start_year <- as.numeric(start_year)\n} else {\n  start_year <- \"30yr\" # This needs to be changed depending on folder name\n}\n\n# Set up start and stop day of year depending on whether it's a leap year or\n# not (need to modify the last day of the year if the year is a leap year \n# and user wants to include it)\n# This does not apply to 30 yr climate data, which would not have a numeric\n# start year\nif (is.numeric(start_year)) {\n  \n  if (start_year %% 4 == 0 & keep_leap == 1) {\n    cat(str_wrap(paste0(start_year, \" is a leap year and leap day (2/29) will be \n                 included in the model\"), width = 80), \"\\n\", \n        file = Model_rlogging, append = TRUE)\n    \n    # Need to add an extra day onto year if all 365 days are being included\n    if (end_doy == 365) {\n      end_doy <- 366\n    }\n    \n  } else if (start_year %% 4 == 0 & keep_leap == 0) {\n     cat(str_wrap(paste0(start_year, \" is a leap year but leap day (2/29) will \n                        not be included in the model\"), width = 80), \"\\n\", \n        file = Model_rlogging, append = TRUE)\n  } else if (start_year %% 4 != 0) {\n    cat(start_year, \"is not a leap year - ignoring 'keep_leap' parameter\\n\", \n        file = Model_rlogging, append = TRUE)\n  }\n}\n\n# Check for appropriate command line parameters\n# Exit program if no pest event maps have been specified but users want pest\n# event maps (pems = 1)\nif (pems == 1 & !(1 %in% c(mapA, mapE, mapL, mapP))) {\n  cat(\"\\n\", str_wrap(\"No pest event maps (mapA, mapE, mapL, mapP) specified; \n                     exiting program\", width = 80), sep = \"\", \n      file = Model_rlogging, append = TRUE)\n  cat(\"\\n\", str_wrap(\"No pest event maps (mapA, mapE, mapL, mapP) specified; \n          exiting program\", width = 80), sep = \"\")\n  q()\n}\n\n# Exit program if an incorrect sampling frequency has been specified\nif (out_option %in% !c(1, 2, 3, 4, 5, 6)) {\n  cat(\"Out_option =\", out_option, \"is unacceptable; exiting program\\n\", \n      file = Model_rlogging, append = TRUE)\n  cat(\"Out_option =\", out_option, \"is unacceptable; exiting program\\n\")\n  q() \n}\n\n# Exit program if ncohort is < 1 (must be at least 1)\nif (ncohort < 1) {\n  cat(\"\\n\", str_wrap(\"Number of cohorts must be greater than or equal to 1; \n                     exiting program\", width = 80), sep = \"\", \n      file = Model_rlogging, append = TRUE)\n  cat(\"\\n\", str_wrap(\"Number of cohorts must be greater than or equal to 1; \n                     exiting program\", width = 80), sep = \"\")\n  q()\n}\n\n# Exit if end day of year is inappropriate\nif (end_doy > 366) {\n  cat(\"\\n\", str_wrap(paste(\"End day of year (end_doy) of\", end_doy, \"is \n                     unacceptable; exiting program\"), width = 80), sep = \"\", \n      file = Model_rlogging, append = TRUE)\n  cat(\"\\n\", str_wrap(paste(\"End day of year (end_doy) of\", end_doy, \"is \n                     unacceptable; exiting program\"), width = 80), sep = \"\")\n  q()\n}\n\n# Create a list of days to use for daily loop\nsublist <- start_doy:end_doy\n\n#### * Format threshold and DD params for Daily Loop ####\n\n# Need to match length and order of stgorder, which is species specific\n\n# Upper and lower thresholds\n# OW stage will have the same threshold as actual stage (e.g., OWadult = adult)\n# Need to match LDT or UDT value to stage, which first requires changing \n# stage abbr to the stage name (\"E\" = \"egg\")\nstage_ldt_list <- list()\nstage_udt_list <- list()\nj <- 1\n\nfor (i in 1:length(stgorder)) {\n  stg_nam <- stgorder[i]\n  stg_nam <- mgsub(string = stg_nam, # Requires \"mgsub\" package\n                   pattern = c(\"OE\", \"OL\", \"OP\", \"OA\", \"E\", \"L\", \"P\", \"A\"), \n                   replacement = c(\"egg\", \"larvae\", \"pupae\", \"adult\", \"egg\", \n                                   \"larvae\", \"pupae\", \"adult\"))\n  stage_ldt_val <- get(paste0(stg_nam, \"LDT\")) # returns LDT value for stage\n  stage_ldt_list[[j]] <- stage_ldt_val\n  stage_udt_val <- get(paste0(stg_nam, \"UDT\")) # returns UDT value for stage\n  stage_udt_list[[j]] <- stage_udt_val\n  j <- j + 1\n}\n\n# DD parameters - OW stage has it's own DD, so change stage abbr. to stage \n# name or \"OW\" plus stage name\nstage_dd_list <- list()\nj <- 1\n\nfor (i in 1:length(stgorder)) {\n  stg_nam <- stgorder[i]\n  stg_nam <- mgsub(string = stg_nam, \n                   pattern = c(\"OE\", \"OL\", \"OP\", \"OA\", \"E\", \"L\", \"P\", \"A\"), \n                   replacement = c(\"OWegg\", \"OWlarvae\", \"OWpupae\", \"OWadult\", \n                                   \"egg\", \"larvae\", \"pup\", \"adult\"))\n  stage_dd_val <- get(paste0(stg_nam, \"DD\")) # returns DD value for stage\n  stage_dd_list[[j]] <- stage_dd_val\n  j <- j + 1\n}\n\n# Put the values in the list into a numeric vector\nstage_ldt <- as.numeric(do.call(cbind, stage_ldt_list))\nstage_udt <- as.numeric(do.call(cbind, stage_udt_list))\nstage_dd <- as.numeric(do.call(cbind, stage_dd_list))\n\n# Cohort response parameters\n# SD is equal the square root of the variance (sigma-squared) parameter\n# May consider changing length.out to something else in future versions...\n# Also consider making the percent (in cohort_distro) an input parameter\nxdist <- seq(xdist1, xdist2, length.out = 1000)\nydist <- dnorm(xdist, mean = distro_mean, sd = sqrt(distro_var))\n\ninputdist <- data.frame(x = xdist, y = ydist) %>% \n  arrange(x) %>% \n  mutate(CDF = cumsum(y/sum(y)))\ncohort_distro <- CohortDistrib(dist = inputdist, numstage = ncohort, perc = .99)\nrelpopsize <- cohort_distro$weights\n\n# Parameters of required degree-days\n# Replace OW gen with emergence distro values\nif (ncohort == 1) {\n  ddpar <- matrix(stage_dd, nrow = 1, byrow = TRUE)\n  stage_dd <- ddpar\n} else {\n  ddpar <- cbind(cohort_distro$means, \n                 matrix(rep(stage_dd[-1], nrow(cohort_distro)), \n                        nrow = nrow(cohort_distro), byrow = TRUE))\n  stage_dd <- ddpar\n}\n\n# (4). METADATA OUTPUT FILE -----\n\n# Push out a metadata file with all inputs used in model\ncat(\"\\nMETADATA: creating metadata file for all inputs used in model\\n\", \n    file = Model_rlogging, append = TRUE)\ncat(\"\\nMETADATA: creating metadata file for all inputs used in model\\n\")\n\n# Create the metadata file\nsetwd(output_dir)\nmetadata <- sprintf(\"%s%s\", \"./\", \"/Logs_metadata/metadata.txt\")\ncat(\"### Metadata for DDRP v2 ###\\n\", file = metadata)\n\n# Document species information\ncat(\"\\n### Model Species Parameters ###\\n Species Abbrev:\", spp, \n    \"\\n Full Name:\", fullname, \n    \"\\n Pest of:\", pestof,\n    \"\\n Overwintering Stage:\", owstage, file = metadata, append = TRUE)\n\n# Document developmental threshold temperatures\ncat(\"\\n \\n Developmental threshold temperatures\",\n    \"\\n Egg Lower Devel Threshold:\", eggLDT, \n    \"\\n Egg Upper Devel Threshold:\", eggUDT, \n    \"\\n Larvae Lower Devel Threshold:\", larvaeLDT, \n    \"\\n Larvae Upper Devel Threshold:\", larvaeUDT, \n    \"\\n Pupae Lower Devel Threshold:\", pupaeLDT,\n    \"\\n Pupae Upper Devel Threshold:\", pupaeUDT, \n    \"\\n Adult Lower Devel Threshold:\", adultLDT, \n    \"\\n Adult Upper Devel Threshold:\", adultUDT, file =  metadata, append = T)\n\n# Document stage durations\ncat(\"\\n\\n Stage durations in degree-days (DDs)\",\n    \"\\n Egg DDs:\", eggDD, \n    \"\\n Larvae DDs\", larvaeDD, \n    \"\\n Pupae DDs:\", pupDD, \n    \"\\n Adult DDs:\", adultDD, \n    file = metadata, append = TRUE)\n\n# Document climate stress exclusion parameter values, if applicable\nif (exclusions_stressunits) {\n  cat(\"\\n \\n Climate stress parameters\",\n      \"\\n Lower Cold Threshold:\", coldstress_threshold, \n      \"\\n Upper Heat Threshold:\", heatstress_threshold,\n      \"\\n Max Cold Units (lower bound):\", coldstress_units_max1, \n      \"\\n Max Cold Units (upper bound):\", coldstress_units_max2,\n      \"\\n Max Heat Stress Units (lower bound):\", heatstress_units_max1,\n      \"\\n Max Heat Stress Units (upper bound):\", heatstress_units_max2, \n      file = metadata, append = TRUE)\n}\n\n# Document Pest Event Map parameter values, if applicable\nif (pems) {\n  cat(\"\\n \\n Pest Event Map parameters\",\n  \"\\n Number of generations to make Pest Event Maps (PEMs): \", PEMnumgens,\n  \"\\n Egg Event DDs and Label: \", eggEventDD, \" (\", eggEventLabel,\")\", \n  \"\\n Larvae Event DDs and Label: \", larvaeEventDD, \" (\", larvaeEventLabel, \")\",\n  \"\\n Pupae Event DDs and Label: \", pupaeEventDD, \" (\", pupaeEventLabel, \")\",\n  \"\\n Adult Event DDs and Label: \", adultEventDD, \" (\", adultEventLabel, \")\",\n  sep = \"\", file = metadata, append = TRUE)\n}\n\ncat(\"\\n\\n### Model Input Parameters ###\\n Start Year:\", start_year, \n    \"\\n Weather data for forecasts:\", forecast_data, \n    \"\\n Start day-of-year:\", start_doy,\n    \"\\n End day-of-year:\", end_doy, \n    \"\\n Region:\", region_param, \n    \"\\n Climate stress exclusion maps:\", exclusions_stressunits, \n    \"\\n Pest Event Maps:\", pems,    \n    \"\\n Adult Event Maps:\", mapA, \n    \"\\n Egg Event Maps:\", mapE, \n    \"\\n Larvae Event Maps:\", mapL, \n    \"\\n Pupae Event Maps:\", mapP,\n    \"\\n Output_Dir:\", out_dir, \n    \"\\n Output option:\", out_option, \n    \"\\n No. of cohorts:\", ncohort, \n    \"\\n Mean of end of OW stage (DDs):\", distro_mean, \n    \"\\n Low bound of end of OW stage (DDs), xdist:\", xdist1, \n    \"\\n High bound of end of OW stage (DDs), ydist:\", xdist2, \n    \"\\n Variance in end of OW stage (DDs):\", distro_var,\n    \"\\n Shape of distribution of end of OW stage (DDs):\", distro_shape, \n    \"\\n Plot odd gens only:\", odd_gen_map, \n    file = metadata, append = TRUE)\n\n# Make a table of stage DDs for each cohort and print to metadata\nstage_dd.print <- as.data.frame(stage_dd)\nstage_dd.print[1] <- round(stage_dd.print[1], 0)\ncolnames(stage_dd.print) <- stgorder\nstage_dd.print <- cbind(\"cohort\" = as.integer(rownames(stage_dd.print)), \n                        data.frame(stage_dd.print, row.names = NULL))\n\ncat(\"\\n\\n### Durations (in degree-days) of stages in each of\", \n    ncohort, \"cohorts ###\\n\", file = metadata, append = TRUE) \nsuppressWarnings(write.table(stage_dd.print, file = metadata, \n                             row.names = FALSE, \n                             col.names = colnames(stage_dd.print), \n                             append = TRUE))\n\ncat(\"\\nDurations (degree-days) of stages in each of\", ncohort, \"cohorts:\\n\\n\") \nprint(stage_dd.print, row.names = FALSE)\n\ncat(\"Done writing metadata file\\n\\n\", forecast_data, \" DATA PROCESSING\\n\", \n    sep = \"\", file = Model_rlogging, append = TRUE)\ncat(\"\\nDone writing metadata file\\n\\n\", forecast_data, \" DATA PROCESSING\\n\",\n    sep = \"\")\n\n# (5). WEATHER DATA LOADING AND PROCESSING -----\n\n# Weather inputs and outputs - PRISM climate data w/subdirs 4-digit year\n# New feature - choose whether to use PRISM or NMME for weather forecasts \n# (forecast_data = PRISM, or forecast_data = NMME)\ntminfiles <- list.files(path = prism_dir, \n                        pattern = glob2rx(paste0(\"*PRISM_tmin_*\", \n                                                 start_year, \"*.bil$*\")), \n                        all.files = FALSE, full.names = TRUE, recursive = TRUE)\nif (length(tminfiles) == 0) {\n  cat(\"Could not find tmin files - exiting program\\n\", \n      file = Model_rlogging, append = TRUE) \n  cat(\"Could not find tmin files - exiting program\\n\") \n  q()\n}\n\ntminfiles <- ExtractBestPRISM(tminfiles, forecast_data, \n                              keep_leap)[start_doy:end_doy]\n\ntmaxfiles <- list.files(path = prism_dir, \n                        pattern = glob2rx(paste0(\"*PRISM_tmax_*\",\n                                                 start_year, \"*.bil$*\")), \n                        all.files = FALSE, full.names = TRUE, recursive = TRUE)\n\nif (length(tmaxfiles) == 0) {\n  cat(\"Could not find tmax files - exiting program\\n\", \n      file = Model_rlogging, append = TRUE) \n  cat(\"Could not find tmax files - exiting program\\n\") \n  q()\n}\n\ntmaxfiles <- ExtractBestPRISM(tmaxfiles, forecast_data, \n                              keep_leap) [start_doy:end_doy]\n\n## Extract date from temperature files using regex pattern matching\ndats <- unique(regmatches(tminfiles, regexpr(pattern = \"[0-9]{8}\", \n                                             text = tminfiles)))\n\n# Specify sampling frequency (how many days until output maps are generated?)\n# This feature may be removed in production version\nif (out_option == 1) {\n  sample_freq <- 30 # Monthly maps\n} else if (out_option == 2) {\n  sample_freq <- 14  # Biweekly maps\n} else if (out_option == 3) {\n  sample_freq <- 10 # Dekad maps\n} else if (out_option == 4) {\n  sample_freq <- 7  # Weekly maps\n} else if (out_option == 5) {\n  sample_freq <- 2  # Even day maps\n} else if (out_option == 6) {\n  sample_freq <- 1 # Daily maps\n}\n\n# Make vector of dates to use when processing results \n# The current date will be sampled if it's the current year.\n# The last date of year will always be sampled.\n# Using \"unique\" will only keep date if it doesn't already occur in vector\n# This happens if the end day of year is a multiple of the sampling frequency \n# (e.g. 1 to 300, w/ a 30 day sampling frequency), or if the current date falls\n# within the sampling frequency\ntoday_dat <- strftime(Sys.time(), format = \"%Y%m%d\")\ncurrent_year <- strftime(Sys.time(), format = \"%Y\")\n\nif (start_year == current_year) {\n  dats2 <- sort(as.numeric(unique(c(dats[seq(0, length(dats), sample_freq)], \n                  today_dat, last(dats)))))\n} else {\n   dats2 <- sort(as.numeric(unique(c(dats[seq(0, length(dats), sample_freq)],\n                                      last(dats)))))\n}\n\ndats2 <- as.character(dats2) # Need to be in character format for plotting\nnum_dats <- length(dats2) # How many sampled dates? \n\n# Create vector of days in the sublist that will be sampled (rasters are saved \n# for those days), and also tack on the last day in the list. \nsample_pts <- c(sublist[seq(0, length(sublist), sample_freq)],\n                last(sublist))\n\n# Add the present day if DDRP run is being run for the current year.\nif (start_year == current_year) {\n  today_doy <- strftime(Sys.time(), format = \"%j\") # Day of year\n  sample_pts <- sort(as.numeric(unique(c(sample_pts, today_doy))))\n}\n\n# Keep only unique sampling points (there may be duplicates for example\n# if the present day is already in the list).\nsample_pts <- unique(sample_pts)\n\n# Log file and terminal messages\ncat(\"Finished loading \", forecast_data, \" files for \", \n    length(start_doy:end_doy), \" days\\nCreating template file for \", \n    region_param, \"\\n\", sep = \"\", file = Model_rlogging, append = TRUE)\ncat(\"\\nFinished loading \", forecast_data, \" files for \", \n    length(start_doy:end_doy), \" days\\n\\nCreating template file for \", \n    region_param, \"\\n\", sep = \"\")\n\n### * Create blank template from a temp file\n# This template is used for cropping the temperature (tmin, tmax) rasters\nREGION <- Assign_extent(region_param) # Bounding box\ntemplate <- crop(raster(tminfiles[1]), REGION) # Template for cropping\ntemplate[!is.na(template)] <- 0\ndataType(template) <- \"INT2U\"\n\n#### * If CONUS or EAST, split template into tiles (and run in parallel)\n# Benefit of tiles is lost for smaller regions, so these are not split\n# SpaDES.tools requires the 'sf' package, which requires a newer version of GDAL\n# .inorder must be set to TRUE so that output files are in correct order!\n\n# Register DoParallel\n# The \"RegCluster\" function creates a set of copies of R running in parallel and \n# communicating over sockets (parallel socket clusters). The value may be \n# specified manually; however, here the value is estimated based on the number \n# of available cores on the computer or server DDRP is being run on. \n# Specifying too many clusters will overload the computer.\nncores <- detectCores()\n\n# The \"RegCluster\" function determines an appropriate # of cores depending on \n# the \"region_param\" and \"ncohort\" parameters, so the server doesn't become\n# overloaded\nRegCluster(round(ncores/4))\n\nif (region_param %in% c(\"CONUS\", \"EAST\")) {\n  # Split template (2 pieces per side)\n  tile_list <- SplitRas(template, ppside = 2, save = FALSE, plot = FALSE) \n  tile_n <- 1:length(tile_list) # How many tiles?\n  cat(\"Splitting template into\", length(tile_list), \"tiles\\n\", \n      file = Model_rlogging, append = TRUE)\n  \n  # Name the 4 tiles (tile1, tile2, tile3, tile4)\n  template <- mapply(function(n, t) {\n    names(n) <- paste0(\"tile\", t)\n    return(n)\n  }, n = tile_list, t = tile_n )\n  \n  rm(tile_list)\n  \n  # Crop temp files by each template tile\n  cat(\"Cropping tmax and tmin tiles for\", region_param, \"\\n\", \n      file = Model_rlogging, append = TRUE)\n  cat(\"\\nCropping tmax and tmin tiles for\", region_param, \"\\n\")\n  \n  tmax_list <- foreach(tile = template, .packages = \"raster\", \n                       .inorder = FALSE) %:% \n    foreach(tmax = tmaxfiles, .packages = \"raster\", .inorder = TRUE) %dopar% { \n      m <- as.matrix(crop(raster(tmax), tile))\n    }\n  \n  tmin_list <- foreach(tile = template, .packages = \"raster\", \n                       .inorder = FALSE) %:% \n    foreach(tmin = tminfiles, .packages = \"raster\", .inorder = TRUE) %dopar% { \n      m <- as.matrix(crop(raster(tmin), tile))\n    }\n  \n# If region is not CONUS or EAST, simply crop temp files by the single template\n} else {\n  cat(\"Cropping tmax and tmin tiles for\", region_param, \"\\n\", \n      file = Model_rlogging, append = TRUE)\n  cat(\"\\nCropping tmax and tmin tiles for\", region_param, \"\\n\")\n  \n  tmax_list <- foreach(t = tmaxfiles, .packages = \"raster\", \n                       .inorder = TRUE) %dopar% {\n    m <- as.matrix(crop(raster(t), template))\n  }\n\n  tmin_list <- foreach(t = tminfiles, .packages = \"raster\", \n                       .inorder = TRUE) %dopar% {\n    m <- as.matrix(crop(raster(t), template))\n  }\n  \n}\n\nstopCluster(cl)\nrm(cl)\n\ncat(\"Done processing \", forecast_data, \" data\\n\\nDAILY LOOP\\n\", sep = \"\",\n    file = Model_rlogging, append = TRUE)\ncat(\"\\nDone processing \", forecast_data, \" data\\n\\nDAILY LOOP\\n\", sep = \"\")\n\n## (6). RUN THE DAILY LOOP -----\n# First set up number of cores to use\n# IMPORTANT: using too many cores will result in low memory, killing the daily \n# loop part-way through.\n\n# For mclapply: Can not use >1 core on Windows, so detect OS\n# TO DO: Resolve \"foreach\" issue with Daily Loop for CONUS so don't need this\nif (grepl(\"Windows\", Sys.info()[1])) {\n  mc.cores <- 1\n} else {\n  mc.cores <- 4 # use 4 here, because there are 4 tiles being run in parallel\n}\n\n# Split cohorts into smaller chunks for CONUS and EAST to avoid overloading \n# memory when running in parallel.\nif (region_param %in% c(\"CONUS\", \"EAST\")) {\n  cohort_chunks <- split(1:ncohort, ceiling(1:length(1:ncohort)/2)) \n} else {\n  cohort_chunks <- split(1:ncohort, ceiling(1:length(1:ncohort)/7))\n}\n\ntic(\"Daily loop run time\") # Start timing the daily loop run-time\n# cat(\"DAILY LOOP: daily loop log files show loop progress and \n# output file info\\n\", file = Model_rlogging, append = TRUE)\ncat(\"Sampling every\", sample_freq, \"days between\", first(dats), \"and\", \n    last(dats), \"\\n\", file = Model_rlogging, append = TRUE) \ncat(\"\\nSampling every\", sample_freq, \"days between\", first(dats), \"and\", \n    last(dats), \"\\n\") \n\n# Run it! If there is an error the program will stop\n\ntryCatch(\n  {\n    \n    RegCluster(round(ncores/4))\n    \n    # If the region is CONUS or EAST, then both cohorts and tiles will be run in\n    # parallel. To avoid overloading the server, mc.cores = 4 (for the 4 tiles,\n    # which keeps load at appropriate level. If a smaller \n    if (region_param %in% c(\"CONUS\", \"EAST\")) {\n\n      # Total number of nodes is mc.cores * 2 because use mclapply twice in loop\n      for (c in cohort_chunks) {\n        cat(\"Running daily loop for cohorts\", as.character(c), \"\\n\", \n            file = Model_rlogging, append = TRUE)\n        cat(\"\\nRunning daily loop for cohorts\", as.character(c), \"\\n\")\n        cohort_vec <- unname(unlist(c)) # change to an unnamed vector\n        # TO DO: Can not get \"foreach\" loop to run this analysis. This issue \n        # should be resolved if DDRP will be run on Windows, because Windows \n        # is incapable of forking with the \"mclapply\" function. \n        #foreach(cohort = cohort_vec, .packages = pkgs, .inorder = FALSE) %:% \n        #  foreach(tile_num = 1:length(template), .packages = pkgs, \n        #        .inorder = FALSE) %dopar% {\n        mclapply(cohort_vec, function(cohort) {\n          mclapply(1:length(template), function(tile_num) {\n            tile <- template[[tile_num]]\n            DailyLoop(cohort, tile_num, tile)\n          }, mc.cores = mc.cores)\n         }, mc.cores = mc.cores)  \n        }\n      #}\n      \n      stopCluster(cl)\n      rm(cl)\n      \n    } else {\n\n      # If the region is not CONUS or EAST, then we don't need to run function \n      # for multiple tiles.\n      for (c in cohort_chunks) {\n        cat(\"Running daily loop for cohorts\", as.character(c), \"\\n\", \n            file = Model_rlogging, append = TRUE)\n        cat(\"\\nRunning daily loop for cohorts\", as.character(c), \"\\n\")\n        cohort_vec <- unname(unlist(c)) # change to an unnamed vector\n        # Only need to run cohorts in parallel\n        RegCluster(round(ncores/4))\n        foreach(cohort = cohort_vec, .packages = pkgs, \n                .inorder = FALSE) %dopar% {\n          DailyLoop(cohort, NA, template)\n        }\n        \n        stopCluster(cl)\n        rm(cl)\n      }\n    }\n  },\n  \n  error = function(e) {\n    cat(\"Error in Daily Loop\\n\", \n        file = Model_rlogging, append = TRUE) \n    cat(\"\\nError in Daily Loop\\n\")\n})\n\n# Free up memory - delete unneeded large objects\nrm(DailyLoop, template, tmaxfiles, tmax_list, tminfiles, tmin_list)\n\n# Document daily loop execution time\nloop_exectime <- toc(quiet = TRUE)\nloop_exectime <- (loop_exectime$toc - loop_exectime$tic) / 60 \n\ncat(\"Daily loop done (run time = \", round(loop_exectime, digits = 2), \" min)\",\n    \"\\n\\nFINAL ANALYSES AND MAP PRODUCTION\\n\", sep = \"\",\n    file = Model_rlogging, append = TRUE) \ncat(\"\\nDaily loop done (run time = \", round(loop_exectime, digits = 2), \" min)\",\n    \"\\n\\nFINAL ANALYSES AND MAP PRODUCTION\\n\", sep = \"\")\n\n#(7). PROCESS DAILY LOOP RESULTS -----\nsetwd(output_dir)\n\ntic(\"Data processing run time\") # Start timing for data processing\n\n# Create a directory (\"Misc_output\") to put secondary outfiles\ndir.create(\"Misc_output\")\n\n#### * If CONUS or EAST, merge and delete tiles ####\n# If CONUS or EAST, merge the tiles\nif (region_param %in% c(\"CONUS\", \"EAST\")) {\n  cat(\"\\nMerging tiles for\", region_param, \"\\n\\n\", \n      file = Model_rlogging, append = TRUE)\n  cat(\"\\nMerging tiles for\", region_param, \"\\n\")\n  # Get list of brick files for each tile, the type of file, \n  # its cohort number, and then make a list of the file types\n  # File types are split up to avoid overloading sytem when running in parallel\n  brick_files <- list.files(pattern = glob2rx(\"*cohort*tile*tif$\"), \n                            recursive = FALSE)\n  type_list <- unique(str_split_fixed(brick_files, \n                                      pattern = \"_cohort\", 4)[,1]) \n  type_list_split <- split(type_list, ceiling(1:length(type_list)/3)) \n  cohorts <- unique(str_split_fixed(brick_files, pattern = \"cohort\", 4)[,2])\n  cohorts <- unique(substring(cohorts, 1, 1)) # Vector of cohorts (1, 2, 3, ...)\n  \n  # For each file type, merge the tiles for all cohorts\n  # File type and cohorts are both run in parallel to increase speed\n  # If system is overloaded then consider: \n  # 1) splitting up the cohorts list (as in the \"type_list_split\"); or \n  # 2) decreasing the number of splits in \"type_list_split\")\n  RegCluster(4)\n  \n  mrg_by_type <- foreach(type = type_list_split, .packages = pkgs, \n                         .inorder = FALSE) %dopar% {\n    type_vec <- unname(unlist(type)) # Change to an unnamed vector\n    for (t in type_vec) {\n      # If type is exclusion, stressunits, or ddtotal files,\n      # then just do cohort 1; no other cohorts present\n      if (grepl(\"Stress_Excl|Stress_Units|DDtotal\", t)) {\n        CombineMaps(brick_files, t, \"1\")\n        cat(\"Merged\", t, \"tiles for cohort 1\\n\",\n            file = Model_rlogging, append = TRUE)\n      # If another file type, then merge tiles for all cohorts\n      } else {\n        foreach(c = cohorts, .packages = pkgs, .inorder = TRUE) %dopar% {\n          CombineMaps(brick_files, t, c)\n          cat(\"Merged\", t, \"tiles for cohort\", c, \"\\n\",\n              file = Model_rlogging, append = TRUE)\n        }\n\n      } \n    }\n  }\n  \n  stopCluster(cl)\n  rm(cl)\n  \n  cat(\"\\nDone merging tiles\\n\", file = Model_rlogging, append = TRUE)\n  cat(\"\\nDone merging tiles\\n\")\n}\n\n# If CONUS or EAST, remove tile files, but first check that merged files \n# exist for each type (e.g., Lifestage, NumGen, ...)\nif (region_param %in% c(\"CONUS\", \"EAST\")) {\n  cat(\"\\nDeleting tiles for\", region_param, \"\\n\\n\", \n      file = Model_rlogging, append = TRUE)\n  cat(\"\\nDeleting tiles for\", region_param, \"\\n\")\n  for (t in type_list) {\n    # Should only be a single merged file for these types\n    # Remove the \"_all\" from the name of the file - this isn't needed\n    if (grepl(\"Stress_Excl|Stress_Units|DDtotal\", t)) {\n      fl <- list.files(pattern = glob2rx(paste0(\"*\", t, \"_*all*tif$\")))\n      if (length(fl == 1)) {\n        unlink(list.files(pattern = glob2rx(paste0(\"*\", t, \"_*tile*tif$\"))))\n      }\n     \n      # For other types, the number of merged files should equal the number \n      # of cohorts. The exception is if OW stage DD distro parameters for \n      # cohorts results in some cohorts not making DD cutoffs for PEMs - \n      # a warning will be recorded if this is the case\n    } else {\n      fls <- list.files(pattern = glob2rx(paste0(\"*\", t, \"_*all*tif$\")))\n      if (length(fls) == ncohort) {\n        unlink(list.files(pattern = glob2rx(paste0(\"*\", t, \"_*tile*tif$\"))))\n        cat(\"Deleted tile files for\", t, \"\\n\", \n            file = Model_rlogging, append = TRUE)\n        # Generate a warning message if some cohorts are missing\n      } else {\n        unlink(list.files(pattern = glob2rx(paste0(\"*\", t, \"_*tile*tif$\"))))\n        cat(\"\\nWarning: only\", length(fls), \n            \"cohort files found for\", t, \"- check params\\n\", \n            file = Model_rlogging, append = TRUE)\n        cat(\"\\nWarning: only\", length(fls), \n            \"cohort files found for\", t, \"- check params\\n\")\n      }\n    }\n  }\n  \n  # Remove \"_all\" from file names - not needed\n  fls <- list.files(pattern = \"*tif$\")\n  file.rename(from = fls, to = sub(pattern = \"_all.tif\", \n                                  replacement = \".tif\", fls))\n  \n  cat(\"\\nDone deleting tile files\\n\", file = Model_rlogging, append = TRUE)\n  cat(\"\\nDone deleting tile files\\n\")\n}\n\n#### * Some ggplot2 settings ####\n# Some ggplot2 settings are specified here, but other settings are specified\n# in the functions file\n\n# Map production in ggplot requires specifying plot.height and plot.width\n# These need to be dynamic because regions have different aspect ratios, \n# which results warped looking maps\n# Calculate bounding box (xmin, xmax, ymin, ymax) of REGION \ncoord <- coord_quickmap(xlim = c(REGION@xmin, REGION@xmax), \n                        ylim = c(REGION@ymin, REGION@ymax), expand = FALSE)\nasp <- coord$aspect(list(x.range = c(REGION@xmin, REGION@xmax), \n                         y.range = c(REGION@ymin, REGION@ymax))) # aspect ratio\n\n# Adjust base_size for ggplot2 (font size) according to aspect ratio\nif (asp >= 1.7) {\n  base_size <- 10.5\n  legend_units <- 1.4\n} else if (asp >= 1.5 & asp < 1.7) {\n  base_size <- 9.5\n  legend_units <- 1.3\n} else if (asp >= 1.2 & asp < 1.5) {\n  base_size <- 8.5 \n  legend_units <- 1.2\n} else if (asp < 1.2 & asp >= 0.6) {\n  base_size <- 7\n  legend_units <- 1\n} else if (asp < 0.6 & asp >= 0.45) {\n  base_size <- 5.7\n  legend_units <- 0.6\n} else if (asp < 0.45) {\n  base_size <- 5.2\n  legend_units <- asp\n}\n\n# Theme to use for plots\nmytheme <- theme(legend.text = element_text(size = rel(1)), \n  legend.title = element_text(size = rel(1.2), face = \"bold\"),\n  legend.position = \"right\", \n  legend.justification = \"left\",\n  legend.margin = margin(t = 0, r = 0.10, b = 0, l = 0.10, unit = \"cm\"),\n  legend.key.width = unit(legend_units, \"line\"), \n  legend.key.height = unit(legend_units, \"line\"),\n  plot.title = element_text(size = rel(1.55), face = \"bold\", hjust = 0.5, \n                            vjust = -3, lineheight = 1, \n                            margin = margin(t = 0, r = 0, b = 2, l = 0)), \n  plot.subtitle = element_text(size = rel(1.25), hjust = 0.5, vjust = -3, \n                               lineheight = 1, \n                               margin = margin(t = 5, r = 0, b = 15, l = 0)),\n  plot.margin = margin(t = 0.05, r = 0.25, b = 0.05, l = 0.25, unit = \"cm\"),\n  panel.grid.major = element_blank(), panel.grid.minor = element_blank(), \n  panel.background = element_blank(), panel.border = element_blank(),\n  axis.title.x = element_blank(), \n  axis.title.y = element_blank(), \n  axis.ticks = element_blank(),\n  axis.text.x = element_blank(), \n  axis.text.y = element_blank())\n\n### * DDtotal and climate stress ####\n\nif (exclusions_stressunits) {\n  cat(\"\\n\", str_wrap(\"### SUMMARY MAPS: DDTOTAL, CLIMATE STRESS EXCL., AND \n                     CLIMATE STRESS UNITS ###\", width = 80), sep = \"\", \n      file = Model_rlogging, append = TRUE)\n  cat(\"\\n\", str_wrap(\"SUMMARY MAPS: DDTOTAL, CLIMATE STRESS EXCL., AND CLIMATE \n               STRESS UNITS\", width = 80), \"\\n\", sep = \"\")\n} else {\n  cat(\"\\n### SUMMARY MAPS: DDTOTAL ###\", file = Model_rlogging, append = TRUE)\n  cat(\"\\nSUMMARY MAPS: DDTOTAL\\n\")\n}\n\n# Remove \"cohort1\" from DDtotal and climate stress raster file names\nfls <- list.files(pattern = glob2rx(\"*Stress_Excl|Stress_Units|DDtotal*tif$\"))\nfl_rename <- lapply(fls, function(fl) {\n  file.rename(from = fl, to = sub(pattern = \"_cohort1\", replacement = \"\", fl))\n})\n\n# Split up the dates into chunks (no chunks have single dates - this results in\n# warning messages. Splitting up the dates avoids overloading the server w/ \n# running too many dates in parallel.\ndats_list <- split(dats2, ceiling(seq_along(dats2)/(length(dats2)/4)))\n\n# For each date in a date chunk, plot and save summary maps for:\n# degree-day accumulation, cold stress unit accumulation, cold stress \n# exclusion, heat stress unit accumulation, heat stress exclusion, and all \n# stress exclusion\n\nRegCluster(round(ncores/3))\n\n#for (dat in dats_list) {\ndd_stress_results <- foreach(dat = dats_list, .packages = pkgs, \n                         .inorder = TRUE) %:%\n  foreach(d = unname(unlist(dat)), .packages = pkgs, .inorder = TRUE) %dopar% {\n  \n  dat_vec <- unname(unlist(dat)) # change to an unnamed date vector\n  #for (d in dat_vec) {\n      # Get position (layer) of date in raster brick\n      lyr <- which(dats2 == d)\n      # Make the plots\n      PlotMap(subset(brick(\"DDtotal.tif\"), lyr), d, \n              \"Degree day (DD) accumulation\", \"Degree Days\", \n              \"Misc_output/DDtotal\")\n\n      if (exclusions_stressunits) {\n        \n        # Cold stress unit accumulation\n         PlotMap_stress(subset(brick(\"Cold_Stress_Units.tif\"), lyr), d, \n                       coldstress_units_max1, coldstress_units_max2, \n                       \"Cold stress units\", \"Cold Stress Units\", \n                       \"Misc_output/Cold_Stress_Units\")\n\n        # Cold stress exlusions (-1 = moderate; -2 = severe)\n        PlotMap(subset(brick(\"Cold_Stress_Excl.tif\"), lyr), d, \n                \"Cold stress exclusion\", \"Exclusion status\", \n                \"Misc_output/Cold_Stress_Excl\")\n\n        # Heat unit accumulation\n        PlotMap_stress(subset(brick(\"Heat_Stress_Units.tif\"), lyr), d, \n                       heatstress_units_max1, heatstress_units_max2, \n                       \"Heat stress units\", \"Heat Stress Units\", \n                       \"Misc_output/Heat_Stress_Units\")\n\n        # Heat stress exclusions (-1 = moderate; -2 = severe)\n        PlotMap(subset(brick(\"Heat_Stress_Excl.tif\"), lyr), d, \n                \"Heat stress exclusion\", \"Exclusion status\", \n                \"Misc_output/Heat_Stress_Excl\")\n\n        # All stress exclusions (cold stress + heat stress exclusions)\n        PlotMap(subset(brick(\"All_Stress_Excl.tif\"), lyr), d, \n                \"All stress exclusion\", \"Exclusion status\", \"All_Stress_Excl\")\n\n      }\n      \n}\n\nstopCluster(cl)\nrm(cl)\n\n# Log messages\nif (exclusions_stressunits) {\n  cat(\"\\n\\n\", str_wrap(\"Done with DDtotal, climate stress exclusions, and \n                       climate stress unit maps\", width = 80), \"\\n\", sep = \"\",\n      file = Model_rlogging, append = TRUE)\n  cat(\"\\n\", str_wrap(\"Done with DDtotal, climate stress exclusions, and climate \n                     stress unit maps\", width = 80), \"\\n\", sep = \"\")\n  cat(\"\\n### \", str_wrap(\"RASTER AND SUMMARY MAP OUTPUTS: STAGE COUNT W/ \n                        CLIM. STRESS EXCL. ###\", width = 80), sep = \"\", \n      file = Model_rlogging, append = TRUE)\n  cat(\"\\nRASTER AND SUMMARY MAP OUTPUTS: STAGE COUNT W/ CLIM. STRESS EXCL.\\n\")\n} else {\n  cat(\"\\n\\nDone with DDtotal maps\\n\", file = Model_rlogging, append = TRUE) \n  cat(\"\\n### RASTER AND SUMMARY MAP OUTPUTS: STAGE COUNT ###\", \n      file = Model_rlogging, append = TRUE)\n  cat(\"\\nRASTER AND SUMMARY MAP OUTPUTS: STAGE COUNT\\n\")\n}\n\n#### * Stage count analysis ####\n\n# This analysis produces gridded and summary map outputs that depicts where \n# each life stage of each generation occurs. Outputs are saved only for the \n# middle cohort, as most of the population will be in the middle, and depicting\n# the results across all cohorts is too complicated. The maps will show all \n# stages of each generation that are present on the sampled day. The StageCount \n# raster is formatted as follows: the number before the decimal is the \n# generation, and the number after the decimal is the life stage, where \n# 1 = OW stage and 2-5 is the remaining stages in consecutive order \n# (e.g. 1 = OWlarvae, 2 = pupae, 3 = adult, 4 = egg, 5 = larvae)\nmiddle_cohort <- ceiling(ncohort/2)\nLfstg <- brick(paste0(\"Lifestage_cohort\", middle_cohort, \".tif\"))/10\nNumGen <- brick(paste0(\"NumGen_cohort\", middle_cohort, \".tif\"))\nStageCt <- overlay(Lfstg, NumGen, fun = function(x, y){ x + y })\nwriteRaster(StageCt, file = \"StageCount\", format = \"GTiff\",  datatype = \"FLT4S\", \n            overwrite = TRUE)\nrm(Lfstg, NumGen, StageCt) # Free up memory\n\n# Create a data frame of life stages spelled out to be used for plotting\n# Stage order is specific to the species, but also need a column for order\n# that stages actually occur (life cycle steps)\nstg_vals <- data.frame(\"stg_name\" = stgorder, \n                       \"stg_num\" = as.character(c(1:5))) \nstg_vals <- stg_vals %>% \n  mutate(stg_name = gsub(\"O\", \"\", stg_name),\n         stg_name = mgsub(stg_name, c(\"E\", \"L\", \"P\", \"A\"), \n                          c(\"eggs\", \"larvae\", \"pupae\", \"adults\")),\n         life_cycle = case_when((stg_name == \"eggs\") ~ 1, \n                                (stg_name == \"larvae\") ~ 2,\n                                (stg_name == \"pupae\") ~ 3,\n                                (stg_name == \"adults\") ~ 4)) \n\n# If climate stress exclusions are specified, then take results from above and \n# substitute values where the species is under severe stress only with \n# -1 (Excl1), and areas where the species is both moderate and severe stress \n# with -1 and -2, respectively (Excl2)\nif (exclusions_stressunits) {\n  # Tack on climate stress data onto stage values data frame\n  stg_vals <- rbind(data.frame(stg_name = c(\"excl.-moderate\", \"excl.-severe\"), \n                    life_cycle = c(-1, -2), stg_num = c(-1, -2)), stg_vals)\n  StageCt_excl1 <- brick(Rast_Subs_Excl(brick(\"StageCount.tif\"), \"Excl1\")) \n  StageCt_excl2 <- brick(Rast_Subs_Excl(brick(\"StageCount.tif\"), \"Excl2\"))\n  # Save raster brick results\n  writeRaster(StageCt_excl1, file = \"StageCount_Excl1\", format = \"GTiff\",  \n              datatype = \"FLT4S\", overwrite = TRUE)\n  writeRaster(StageCt_excl2, file = \"StageCount_Excl2\", format = \"GTiff\",  \n              datatype = \"FLT4S\", overwrite = TRUE)\n  rm(StageCt_excl1, StageCt_excl2) # Free up memory\n}\n\n# Make list of Stage Count raster bricks for plotting\nif (exclusions_stressunits) {\n  StageCt_lst <- c(\"StageCount.tif\", \"StageCount_Excl1.tif\", \n                   \"StageCount_Excl2.tif\")\n} else {\n  StageCt_lst <- c(\"StageCount.tif\")\n}\n\n# Generate summary maps for Stage Count results\n# TO DO: see about making this step faster. Increasing parallel processing\n# here (e.g. for going through the StageCt_lst) overloads server too much.\nRegCluster(round(ncores/3))\n\nfor (i in 1:length(StageCt_lst)) {\n  fl <- StageCt_lst[i]\n  #for (dat in dats_list) {\n  foreach(dat = dats_list, .packages = pkgs, .inorder = TRUE) %:%\n    foreach(d = unname(unlist(dat)), \n            .packages = pkgs, .inorder = TRUE) %dopar% {\n    \n    #dat_vec <- unname(unlist(dat)) # Change to an unnamed date vector\n    \n    #for (d in dat_vec) {\n      \n      # Get position (layer) of date in raster brick, subset layer from bricks,\n      # convert this layer to a data frame, and mutate data to extract gen \n      # number and stage number. Then join to the stg_vals data frame to get\n      # the stage name. These operations are done only if the data are not\n      # climate stress exclusion values (i.e. are greater than 0). The stage\n      # order (stg_order) column is for ordering stages correctly in map legend.\n      lyr <- which(dats2 == d)\n      \n      StageCt_df <- ConvDF(brick(StageCt_lst[i])[[lyr]]) %>% \n        mutate(value_orig = value) %>% # Keep original value (for plotting)\n        mutate(value = round(value, 1)) %>% # Round decimal (must do this)\n        mutate(gen = as.numeric(ifelse(value > 0, \n                            str_split_fixed(value, \"[.]\", 2)[,1], value))) %>%\n        mutate(stg_num = as.character(ifelse(value > 0, \n                              str_split_fixed(value, \"[.]\", 2)[,2], value))) %>%\n        left_join(., stg_vals, by = \"stg_num\") %>%\n        mutate(gen_stg = paste0(gen, \".\", life_cycle)) # Correctly sort legend\n          \n      # Format data values for plotting - Gen 0 = OW gen and ordinal values for\n      # other generations (1st, 2nd, 3rd, etc.). This step is pretty slow - \n      # see if it can be sped up in future version.\n      OW_gen <- StageCt_df %>% \n        filter(gen == 0) %>%\n        mutate(value = paste(\"OW gen.\", stg_name))\n      \n      # Filter out climate stress values to tack on after formatting other data\n      excl_df <- StageCt_df %>% \n        dplyr::filter(value < 0) %>%\n        mutate(gen_stg = ifelse(value == -2, -2, -1))\n          \n      if (any(StageCt_df$gen > 0)) {\n        StageCt_df2 <- StageCt_df %>% \n          filter(gen > 0) %>%\n          mutate(value = \n                   map_chr(gen, function(x) paste(toOrdinal(x), \"gen.\"))) %>% \n          unnest() %>% \n          mutate(value = paste(value, stg_name)) %>%\n          rbind(OW_gen, .) \n      } else {\n        StageCt_df2 <- OW_gen\n      }\n      \n      # Add climate stress values back in\n      if (exclusions_stressunits) {\n        StageCt_df2 <- rbind(StageCt_df2, excl_df)\n      }\n      \n      # Plot the results\n      if (fl == \"StageCount.tif\") {\n        PlotMap(StageCt_df2, d, \"Generation and stage\", \"Gen. x stage\", \n                \"StageCount\")\n      } else if (fl == \"StageCount_Excl1.tif\") {\n        PlotMap(StageCt_df2, d, \n                \"Generation and stage w/ climate stress exclusion\", \n                \"Gen. x stage\", \"StageCount_Excl1\")\n      } else if (fl == \"StageCount_Excl2.tif\") {\n        PlotMap(StageCt_df2, d, \n                \"Generation and stage w/ climate stress exclusion\", \n                \"Gen. x stage\", \"StageCount_Excl2\")\n      }\n  \n    }\n  }\n#}\n\nstopCluster(cl)\nrm(cl)\n\nrm(StageCt_lst)\n\n# Log file messages\nif (exclusions_stressunits) {\n    cat(\"\\n\\n\", str_wrap(\"Done with raster and summary map outputs for \n      StageCount, StageCount_Excl1, and StageCount_Excl2\", width = 80), \n    file = Model_rlogging, sep = \"\", append = TRUE) \n  cat(\"\\n\", str_wrap(\"Done with raster and summary map outputs for StageCount,\n      StageCount_Excl1, and StageCount_Excl2\", width = 80), sep = \"\")\n} else {\n  cat(\"\\n\\nDone with raster and summary map outputs for StageCount\\n\", \n    file = Model_rlogging, append = TRUE)\n  cat(\"\\nDone with raster and summary map outputs for StageCount\\n\")\n}\n\n# If no PEMS, then moving on to Lifestage analyses \nif (!pems & !exclusions_stressunits) {\n  cat(\"\\n\", str_wrap(\"### WEIGHTED RASTER AND SUMMARY MAP OUTPUTS: LIFESTAGE\n                     ###\", width = 80), \"\\n\\nStages: \", \n      paste(stgorder, collapse = \", \"), \n      sep = \"\", file = Model_rlogging, append = TRUE)\n  cat(\"\\nWEIGHTED RASTER AND SUMMARY MAP OUTPUTS: LIFESTAGE ###\",\"\\n\\nStages: \",\n      paste(stgorder, collapse = \", \"), \"\\n\")\n  # If no PEMS but climate stress exclusions, then moving on to Lifestage \n  # analyses that also include climate stress exclusions\n} else if (!pems & exclusions_stressunits) {\n  cat(\"\\n\\n\", str_wrap(\"### WEIGHTED RASTER AND SUMMARY MAP OUTPUTS:\n      LIFESTAGE W/ CLIM. STRESS EXCL. ###\", width = 80), \"\\n\\nStages: \", \n      paste(stgorder, collapse = \", \"), sep = \"\",\n      file = Model_rlogging, append = TRUE)\n  cat(\"\\n\\n\", str_wrap(\"### WEIGHTED RASTER AND SUMMARY MAP OUTPUTS:\n      LIFESTAGE W/ CLIM. STRESS EXCL. ###\", width = 80), \"\\nStages: \", \n      paste(stgorder, collapse = \", \"), sep = \"\")\n  # If PEMS but no climate stress exclusions, then conducting PEM analyses\n} else if (pems & !exclusions_stressunits) {\n  cat(\"\\n### RASTER AND SUMMARY MAP OUTPUTS: PEST EVENT MAPS ###\", sep = \"\",\n      file = Model_rlogging, append = TRUE)\n  cat(\"\\nRASTER AND SUMMARY MAP OUTPUTS: PEST EVENT MAPS\\n\", sep = \"\")\n  # If PEMS and climate stress exclusions, then conducting PEM analyses that \n  # also include climate stress exclusions\n} else if (pems & exclusions_stressunits) {\n  cat(\"\\n\\n\", str_wrap(\"### RASTER AND SUMMARY MAP OUTPUTS: PEST EVENT MAPS W/\n                       CLIMATE STRESS EXCL. ###\", width = 80), sep = \"\",\n      file = Model_rlogging, append = TRUE)\n  cat(\"\\n\\n\", str_wrap(\"RASTER AND SUMMARY MAP OUTPUTS: PEST EVENT MAPS W/\n                CLIMATE STRESS EXCL.\\n\", width = 80), sep = \"\")\n}\n\n#### * Pest Event Maps ####\n\n# Process and plot the Pest Event Maps (PEMs) \n# Currently, the earliest date across cohorts and average data across cohorts \n# is calculated for the last day (last day is last element of \"sublist\" vector)\n\nif (pems) {\n  # Get all PEM files, split them by type (e.g., PEMe1, PEMe2) and stage \n  # (e.g., \"egg\", \"adult\")\n  PEM_files <-  list.files(pattern = glob2rx(\"*PEM*.tif$\")) # all PEM files\n  PEM_types <- unique(substr(PEM_files, start = 1, stop = 5)) # split by type\n  \n  # Create a data frame with PEM labels - the labels will be joined to the \n  # appropriate PEM file below\n  PEM_event_labels <- cbind(data.frame(\"pem_types\" = PEM_types), \n    data.frame(\"gen\" = substr(PEM_types, start = 5, stop = 5)), \n    data.frame(\"stg\" = substr(PEM_types, start = 4, stop = 4)))\n  PEM_event_labels <- PEM_event_labels %>%\n    mutate(genLabel = ifelse(gen == 0, \"date of OW gen.\", \n                      ifelse(gen == 1, \"date of 1st gen.\", \n                      ifelse(gen == 2, \"date of 2nd gen.\", \n                      ifelse(gen == 3, \"date of 3rd gen.\", \n                      ifelse(gen == 4, \"date of 4th gen.\", NA)))))) %>% \n    mutate(eventLabel = ifelse(stg == \"e\", eggEventLabel, \n                        ifelse(stg == \"l\", larvaeEventLabel, \n                        ifelse(stg == \"p\", pupaeEventLabel, \n                        ifelse(stg == \"a\", adultEventLabel, NA))))) %>%\n    mutate(finalLabel = paste(genLabel, eventLabel, sep = \" \")) %>% \n                      dplyr::select(pem_types, finalLabel)\n  \n  # Which PEM is for the OW stage?\n  OW_pem <- paste0(\"PEM\", tolower(substr(owstage, start = 2, stop = 2)), \"0\")\n  \n  # Analyze the PEMs for each cohort in parallel, and then export resulting \n  # rasters and generate summary maps\n  RegCluster(length(PEM_types))\n  \n  foreach(type = PEM_types, .packages = pkgs, .inorder = FALSE) %dopar% {\n  #for (type in PEM_types) {\n   #print(type)\n    # Find files by type (e.g., \"PEMe1\" for each cohort) \n    files_by_type <- PEM_files[grep(pattern = type, x = PEM_files, \n                                    fixed = TRUE)] \n    # Change 0 values to NA so they are not averaged \n    PEM_brk <- brick(raster::stack(files_by_type))\n    PEM_brk[PEM_brk == 0] <- NA\n    \n    # Remove PEM raster brick files if all PEM values are 0 because \n    # there's no point in plotting an all zero result\n    if (sum(matrix(PEM_brk), na.rm = TRUE) == 0) {\n      unlink(list.files(pattern = glob2rx(paste0(\"*\", type, \"_*tif$\"))))\n    # Remove PEM raster brick file if there is only a single unique value\n    # This may happen for the last day of sampling period? (check on this)\n    } else if (length(unique(values(PEM_brk))) < 3) {\n        vals <- unique(getValues(PEM_brk))\n        vals <- vals[!is.na(vals)]\n        if (length(vals) == 1) {\n          unlink(list.files(pattern = glob2rx(paste0(\"*\", type, \"_*tif$\"))))\n        }\n      # If PEM raster brick has data, then process and plot it\n    } else {\n    # Create event label to be used for making summary maps\n      eventLabel_df <- dplyr::filter(PEM_event_labels, PEM_types == type) %>% \n        dplyr::select(finalLabel) %>%\n        mutate(., finalLabel = ifelse(type == OW_pem, paste(\"date of OW gen.\", \n                                              OWEventLabel), finalLabel))          \n        eventLabel <- paste(eventLabel_df$finalLabel)\n        \n      # Remove layers in the PEM stack if they are all NA, and print warning \n      # If this happens, should maybe change cohort emergence params\n      zero_sum <- cellStats(PEM_brk, sum)\n      pem_na <- PEM_brk[[which(zero_sum == 0)]]\n      PEM_brk <- PEM_brk[[which(zero_sum > 0)]]\n      if (nlayers(PEM_brk) < ncohort) {\n        cat(\"\\n\\n\", str_wrap(paste0(\"WARNING: check emergence params - missing \n            cohorts for \", type), width = 80), sep = \"\", file = Model_rlogging, \n            append = TRUE)\n      }\n\n      # Calc. avg. date of pest event across cohorts\n      # Then save raster brick, and create and save summary maps\n      avg_PEM <- calc(PEM_brk, fun = function(x, na.rm= TRUE) { \n        mean(x, na.rm = TRUE) \n        }) # average in day of event among cohorts\n      names(avg_PEM) <- \"Avg\" # name layer for use below\n      SaveRaster2(avg_PEM, paste(\"Avg\", type, last(dats2), sep = \"_\"), \n                  \"INT2U\", paste(\"- Avg.\", eventLabel))\n      PlotMap(avg_PEM, last(dats2), paste(\"Avg.\", eventLabel, sep = \" \"), \n              paste(\"Avg.\", eventLabel, sep = \" \"), \n              paste(\"Avg\", type, sep = \"_\"))\n      \n      # Calc. the earliest date of pest event across cohorts \n      # Then save raster brick, and create and save summary maps\n      # Need to edit event labels if they contain the word \"first\" because this\n      # is highly redundant (e.g. \"earliest first adult emergence\")\n      min_PEM <- calc(PEM_brk, fun = function(x, na.rm= TRUE) { \n        min(x) \n        })\n      names(min_PEM) <- \"Earliest\" # name layer for use below\n      SaveRaster2(min_PEM, paste(\"Earliest\", type, last(dats2), sep = \"_\"), \n                  \"INT2U\", paste(\"- Earliest\", eventLabel))\n      PlotMap(min_PEM, last(dats2), paste(\"Earliest\", eventLabel, sep = \" \"), \n              paste(\"Earliest\", eventLabel, sep = \" \"), \n              paste(\"Earliest\", type, sep = \"_\"))\n      \n      # If climate stress exclusions are specified, then take PEM results from \n      # above and substitute values where the species is under severe stress \n      # only with -1 (Excl1), and areas where the species is under both\n      # moderate and severe stress with -1 and -2, respectively (Excl2)\n      if (exclusions_stressunits) {\n        PEM_list <- list(avg_PEM, min_PEM)\n        foreach(PEM = PEM_list, .packages = pkgs, .inorder = FALSE) %dopar% {\n        #for (PEM in PEM_list) {\n          nam <- names(PEM)\n          # Do calculations\n          PEM_excl1 <- Rast_Subs_Excl(PEM, \"Excl1\")[[1]] # Sev. stress (Excl1) \n          PEM_excl2 <- Rast_Subs_Excl(PEM, \"Excl2\")[[1]] # Both stress (Excl2) \n              \n          # Save raster brick results; create and save summary maps\n          SaveRaster2(PEM_excl1, paste0(nam, \"_\", type, \"Excl1_\", last(dats2)), \n                      \"INT2S\", paste(\"-\", nam, eventLabel))\n          SaveRaster2(PEM_excl2, paste0(nam, \"_\", type, \"Excl2_\", last(dats2)), \n                      \"INT2S\", paste(\"-\", nam, eventLabel))\n          PlotMap(PEM_excl1, last(dats2), paste0(nam, \" \", eventLabel, \n                  \" w/ climate stress exclusion\"), paste0(nam, \" \", eventLabel),\n                  paste0(nam, \"_\", type, \"Excl1\"))\n          PlotMap(PEM_excl2, last(dats2), paste0(nam, \" \", eventLabel, \n                  \" w/ climate stress exclusion\"), paste0(nam, \" \", eventLabel), \n                  paste0(nam, \"_\", type, \"Excl2\"))\n         }\n        }\n      }\n    }\n  \n  stopCluster(cl)\n  rm(cl)\n  \n}\n\n# Remove PEM objects to free up memory, and delete \n# PEM cohort rasters now that they have been processed\nunlink(list.files(pattern = glob2rx(paste0(\"*PEM*cohort*\"))))\nrm(list = ls(pattern = \"PEM|pem_\")) \n  \n# Log file messages\nif (pems & exclusions_stressunits) {\n  cat(\"\\n\\nDone with Pest Event Maps\\n\\n\", str_wrap(\"### WEIGHTED RASTER AND \n      SUMMARY MAP OUTPUTS: LIFESTAGE W/ CLIM. STRESS EXCL. ###\", width = 80), \n      \"\\n\\nStages: \", paste(stgorder, collapse = \", \"), sep = \"\",\n      file = Model_rlogging, append = TRUE)  \n  cat(\"\\n\\nDone with Pest Event Maps\\n\\n\", str_wrap(\"WEIGHTED RASTER AND SUMMARY \n      MAP OUTPUTS: LIFESTAGE W/ CLIM. STRESS EXCL.\", width = 80), \"\\nStages: \",\n      paste(stgorder, collapse = \", \"), \"\\n\", sep = \"\")\n} else if (pems & !exclusions_stressunits) {\n  cat(\"\\n\\nDone with Pest Event Maps\\n\\n\", str_wrap(\"### WEIGHTED RASTER AND  \n      SUMMARY MAP OUTPUTS: LIFESTAGE ###\", width = 80), \"\\n\\nStages: \", \n      paste(stgorder, collapse = \", \"), sep = \"\",\n      file = Model_rlogging, append = TRUE) \n  cat(\"\\nDone with Pest Event Maps\\n\\n\", \n      \"WEIGHTED RASTER AND SUMMARY MAP OUTPUTS: LIFESTAGE\", \"\\nStages: \",\n      paste(stgorder, collapse = \", \"), \"\\n\", sep = \"\")\n}\n\n# Make file lists for weighting the rasters by relative population size\nLfstg_fls <- list.files(pattern = glob2rx(\"*Lifestage_*.tif$\"))\n\n#### * Lifestage raster processing and plots ####\n# Output weighted rasters and summary maps for ALL stages - this splits outs \n# the OW stage separately. Next, output weighted rasters and summary maps for \n# stages that combine OW stage w/ actual stage (e.g. OW adult = adult).\n\n# Match OW stage to actual stage (e.g., OA = adult)\nif (owstage == \"OL\") {\n  stage_list <- c(\"OL\",\"P\",\"A\",\"E\",\"L\")\n} else if (owstage == \"OP\") {\n  stage_list <- c(\"OP\",\"A\",\"E\",\"L\",\"P\")\n} else if (owstage == \"OA\") {\n  stage_list <- c(\"OA\",\"E\",\"L\",\"P\",\"A\")\n} else if (owstage == \"OE\") {\n  stage_list <- c(\"OE\",\"L\",\"P\",\"A\",\"E\")\n}\n\n# What is the non-OW form of the OW stage? (e.g., OWadult = Adult)\nstg_nonOW <- substring(owstage, 2) \n\n# Weight the lifestage rasters to calc. the relative size of the population \n# in any given life stage. For example, if 7 cohorts are run, then results from\n# the 7 cohorts for each date will be combined and \"weighted\" according the \n# relative proportion of population represented by that cohort. \n# Results for the 5 stages (E, L, P, A, and OW stage) are run in parallel.\nRegCluster(round(ncores/5))\n\nforeach(stg = stage_list, .packages = pkgs, .inorder = TRUE) %dopar% {\n#for (stg in stage_list) {\n  #print(stg)\n  # Get stage number of stage, and then rename to a more descriptive name\n  stg_nam <- mgsub(string = stg, pattern = \n                     c(\"OE\", \"OL\", \"OP\", \"OA\", \"E\", \"L\", \"P\", \"A\"), \n                   replacement = c(\"OWegg\", \"OWlarvae\", \"OWpupae\", \"OWadult\",\n                                   \"Egg\", \"Larvae\", \"Pupae\", \"Adult\"))\n\n  if (stg != stg_nonOW) {\n    \n    # Weight the rasters according the proportion of the population \n    # represented by each cohort in that life stage\n    # Weight_rasts accepts 3 arguments: 1) the cohort files; 2) the type\n    # of files; and the life stage being analyzed in numerical form (e.g.\n    # Egg = 2 if the stage order is OA, E, L, P, A)\n    stg_num <- match(stg, stgorder)\n    Lfstg_wtd <- Weight_rasts(Lfstg_fls, \"Lifestage\")\n      \n    # Save raster results\n    SaveRaster2(Lfstg_wtd, paste0(\"Misc_output/\", stg_nam), \"INT2U\",  \n                paste(\"-\", stg_nam, \"relative pop. size for all\", \n                      num_dats, \"dates\")) \n\n    # Create and save summary maps\n    Lfstg_plots <- foreach(lyr = 1:nlayers(Lfstg_wtd), \n                           .packages = pkgs, .inorder = TRUE) %dopar% {\n        lyr_name <- paste0(dats2[[lyr]])\n        PlotMap(Lfstg_wtd[[lyr]], lyr_name, \n                paste0(stg_nam, \" relative pop. size\"), \n                \"Relative pop. size\", paste0(\"Misc_output/\", stg_nam))\n    }\n\n    # If climate stress exclusions are specified, then take weighted lifestage \n    # results from above and substitute values where the species is under severe \n    # stress only with -1 (Excl1), and areas where the species is both moderate \n    # and severe stress with -1 and -2, respectively (Excl2)\n    if (exclusions_stressunits) {\n      \n      rm(Lfstg_plots) # Free up memory\n      \n      # Overlay the All Stress Exclusion maps onto the weighted Lifestage\n      # raster bricks. This is much more memory efficient than weighting\n      # the the LifestageEXCL1 and LifestageEXCL2 rasters separately\n      # NOTE: using do.call w/ brick results in smaller object size than using\n      # raster::stack(Rast_Subs_Excl(Lfstg_wtd, \"Excl1\"))\n      Lfstg_wtd_excl1 <- do.call(brick, Rast_Subs_Excl(Lfstg_wtd, \"Excl1\"))\n      \n      # Severe stress exclusion only\n      SaveRaster2(Lfstg_wtd_excl1, \n                  paste0(\"Misc_output/\", stg_nam, \"_Excl1\"), \n                  \"INT2S\", paste(\"-\", stg_nam, \"relative pop. size for all\", \n                  num_dats, \"dates\"))\n      \n      Lfstg_Excl1_plots <- foreach(lyr = 1:nlayers(Lfstg_wtd_excl1),\n                                   .packages = pkgs, .inorder = TRUE) %dopar% {\n          lyr_name <- paste0(dats2[[lyr]])\n          PlotMap(Lfstg_wtd_excl1[[lyr]], lyr_name, paste(stg_nam, \n                 \"relative pop. size w/ climate stress exclusion\", sep = \" \"), \n                 \"Relative pop. size\", \n                 paste0(\"Misc_output/\", stg_nam, \"_Excl1\"))\n      }\n      \n      rm(Lfstg_wtd_excl1, Lfstg_Excl1_plots) # Free memory\n      \n      # Severe and moderate stress exclusions\n      Lfstg_wtd_excl2 <- do.call(brick, Rast_Subs_Excl(Lfstg_wtd, \"Excl2\"))\n      \n      SaveRaster2(Lfstg_wtd_excl2, \n                  paste0(\"Misc_output/\", stg_nam, \"_Excl2\"), \n                  \"INT2S\", paste(\"-\", stg_nam, \"relative pop. size for all\", \n                                 num_dats, \"dates\")) \n      \n      Lfstg_Excl2_plots <- foreach(lyr = 1:nlayers(Lfstg_wtd_excl2), \n                                   .packages = pkgs, .inorder = TRUE) %dopar% {\n          lyr_name <- paste0(dats2[[lyr]])\n          PlotMap(Lfstg_wtd_excl2[[lyr]], lyr_name, paste(stg_nam, \n                  \"relative pop. size w/ climate stress exclusion\", sep = \" \"), \n                  \"Relative pop. size\", \n                  paste0(\"Misc_output/\", stg_nam, \"_Excl2\"))\n      }\n            \n    rm(Lfstg_wtd_excl2, Lfstg_Excl2_plots) # Free memory\n    \n    }\n    \n  } \n  \n  # If the stage is the non-OW form of the OWstage (i.e., Adult = OWadult,\n  # Larvae = OWlarvae), then the output from each of these should be merged.\n  # It doesn't make sense to have an Adult raster/plot that does not also \n  # include the OW form of that stage. Thus, the OW results (e.g., \"OWadult) are\n  # split out the non-OW form (e.g. \"Adult\") above, but here they are being \n  # combined. \n  # Match overwintering stage to actual stage (e.g. OA = A, OE = E, etc.)\n  \n  else if (stg == stg_nonOW) {\n    stg_num <- match(stg_nonOW, stgorder) # Get stage no. of non-OW stage\n    stg_nonOW_nam <- mgsub(string = stg_nonOW, pattern = c(\"E\", \"L\", \"P\", \"A\"), \n                           replacement = c(\"Egg\", \"Larvae\", \"Pupae\", \"Adult\"))\n    \n    # Weight the rasters to get relative population size of the stage in the\n    # population, and save and plot results. The Weight_rasts function is\n    # written to account for the instance where stg == non_stg_nonOW.\n    Lfstg_incOW_wtd <- Weight_rasts(Lfstg_fls, \"Lifestage\")\n    SaveRaster2(Lfstg_incOW_wtd, paste0(\"Misc_output/\", stg_nonOW_nam), \n                \"INT2U\", paste(\"-\", stg_nonOW_nam, \"relative pop. size for\", \n                               num_dats, \"dates\"))\n    \n    Lfstg_incOW_plots <- foreach(lyr = 1:nlayers(Lfstg_incOW_wtd), \n                                 .packages = pkgs, .inorder = TRUE) %dopar% {\n        lyr_name <- paste0(dats2[[lyr]])\n        PlotMap(Lfstg_incOW_wtd[[lyr]], lyr_name, \n                paste(stg_nonOW_nam, \"relative pop. size\"), \n                \"Relative pop. size\", paste0(\"Misc_output/\", stg_nonOW_nam))\n    }\n        \n    rm(Lfstg_incOW_plots) # Free memory\n    \n    # If climate stress exclusions are specified, then take substitute values \n    # where the species is under severe stress with -1 (Excl1), and areas where \n    # the species is under both moderate and severe stress with -1 and -2, \n    # respectively (Excl2)\n    if (exclusions_stressunits) {\n      \n      # Severe stress exclusion only\n      # Weight rasters, save results, and plot the results\n      #Lfstg_incOW_wtd_excl1_brk <- Weight_rasts(Lfstg_Excl1_fls, \"Lifestage\")\n      Lfstg_incOW_wtd_excl1 <- do.call(brick, \n                                       Rast_Subs_Excl(Lfstg_incOW_wtd, \"Excl1\")) \n        \n      SaveRaster2(Lfstg_incOW_wtd_excl1, \n        paste0(\"Misc_output/\", stg_nonOW_nam, \"_Excl1\"), \"INT2S\", \n        str_wrap(paste(\"-\", stg_nonOW_nam, \" relative pop. size w/ sev. climate \n                       stress exclusion for\", num_dats, \"dates\"), width = 80))\n      \n      Lfstg_incOW_Excl1_plots <- foreach(lyr = 1:nlayers(Lfstg_incOW_wtd_excl1), \n                                    .packages = pkgs, .inorder = TRUE) %dopar% {\n          lyr_name <- paste0(dats2[[lyr]])\n          PlotMap(Lfstg_incOW_wtd_excl1[[lyr]], \n                  lyr_name, paste(stg_nonOW_nam, \n                  \"relative pop. size w/ climate stress exclusion\", sep = \" \"), \n                  \"Relative pop. size\", \n                  paste0(\"Misc_output/\", stg_nonOW_nam, \"_Excl1\"))\n      }\n            \n      rm(Lfstg_incOW_wtd_excl1) # Free memory\n      \n      # Moderate and severe stress exclusions\n      # Lfstg_incOW_wtd_excl2_brk <- Weight_rasts(Lfstg_Excl2_fls, \"Lifestage\")\n      Lfstg_incOW_wtd_excl2 <- do.call(brick, \n                                       Rast_Subs_Excl(Lfstg_incOW_wtd, \"Excl2\")) \n      \n      SaveRaster2(Lfstg_incOW_wtd_excl2, \n        paste0(\"Misc_output/\", stg_nonOW_nam, \"_Excl2\"), \"INT2S\",\n        str_wrap(paste(\"-\", stg_nonOW_nam, \"relative pop. size w/ sev. and mod. \n                       climate stress exclusion for\", num_dats, \"dates\"), \n                 width = 80))\n      \n      Lfstg_incOW_Excl2_plots <- foreach(lyr = 1:nlayers(Lfstg_incOW_wtd_excl2), \n        .packages = pkgs, .inorder = TRUE) %dopar% {\n          lyr_name <- paste0(dats2[[lyr]])\n          PlotMap(Lfstg_incOW_wtd_excl2[[lyr]], lyr_name, \n                  paste(\"All\", tolower(stg_nonOW_nam), \n                  \"relative pop. size w/ climate stress exclusion\", sep = \" \"), \n                  \"Relative pop. size\", paste0(\"Misc_output/\", stg_nonOW_nam, \n                                               \"_Excl2\"))\n      }\n      \n      rm(Lfstg_incOW_wtd_excl2) # Free memory\n    }\n  }\n}\n\nstopCluster(cl)\nrm(cl)\n\n# Delete Lifestage cohort rasters now that they have been processed\nunlink(list.files(pattern = glob2rx(paste0(\"*Lifestage*cohort*\"))))\n\n# Log file messages\nif (exclusions_stressunits) {\n  cat(\"\\n\\n\", str_wrap(\"Done with weighted raster summary map outputs for \n                       Lifestage, Lifestage_Excl1, and Lifestage_Excl2\", \n                       width = 80), \"\\n\\n\", \n      str_wrap(paste(\"### WEIGHTED RASTER OUTPUT: NUMGEN WITH CLIMATE STRESS \n                     EXCL. ###\"), width = 80), sep = \"\", \n      file = Model_rlogging, append = TRUE) \n  cat(\"\\n\", str_wrap(\"Done with weighted raster summary map outputs for \n                       Lifestage, Lifestage_Excl1, and Lifestage_Excl2\", \n                       width = 80), \"\\n\", sep = \"\")\n  cat(\"\\nWEIGHTED RASTER OUTPUT: NUMGEN WITH CLIMATE STRESS EXCL.\", sep = \"\")\n} else {\n  cat(\"\\n\\n\", str_wrap(\"Done with weighted raster summary map outputs for \n                       Lifestage\", width = 80), \"\\n\\n\", \n      \"### WEIGHTED RASTER OUTPUT: NUMGEN ###\", sep = \"\", \n      file = Model_rlogging, append = TRUE) \n  cat(\"\\n\", str_wrap(\"Done with weighted raster and summary map outputs for \n                       Lifestage\", width = 80), \"\\n\\n\", \n      \"WEIGHTED RASTER OUTPUT: NUMGEN\\n\", sep = \"\")\n}\n\n#### * NumGen raster processing ####\n# Note that each generation is output to it's own raster brick (.tif) file, \n# whereas the summary plots show every generation on a given date. There will \n# likely be some overlap between generations, and showing this is not possible\n# if a raster brick combined mulitple generations.\n\n# Calculate the maximum number of generations over sampled period \n# Split out NumGen brick by generation and save \n# First calculate the maximum number of generations over sampled period \nNumGen_fls <- list.files(pattern = glob2rx(paste0(\"NumGen_\", \"*tif$\"))) \nmaxgens <- as.numeric(max(maxValue(raster::stack(NumGen_fls))))\n\nRegCluster(round(ncores/12))\n\nforeach(i = 0:maxgens, .packages = pkgs, \n        .inorder = TRUE) %:%\n  foreach(j = 1:length(NumGen_fls), .packages = pkgs, .inorder = TRUE) %dopar% {\n    \n    #for (j in 1:length(NumGen_fls)) {\n    fl <- NumGen_fls[j]\n    cohort <-  unique(str_split_fixed(fl, \"_|[.]\", 3)[,2])\n    #for (i in 0:maxgens) {\n    Gen_brick <- raster::stack(fl) == i\n    SaveRaster2(Gen_brick, paste(\"Gen\", i, cohort, sep = \"_\"), \"INT2U\", \n                paste(\"- Gen.\", i, \"for all\", num_dats, \"dates\"))\n  }\n#}\n\nstopCluster(cl)\nrm(cl)\n\n# Delete NumGen raster bricks - no longer needed\nunlink(list.files(pattern = glob2rx(paste0(\"*NumGen*cohort*\"))))\n\n# Make a list of cohort bricks for each generation\ngen_fls_lst <- list()\nfor (gen in 0:maxgens) {\n  gen_fls <- list.files(pattern = paste0(\"Gen_\", gen, \"_\"))\n  gen_fls_lst[[gen + 1]] <- gen_fls \n}\n\nnames(gen_fls_lst) <- paste(c(rep(\"Gen\", 1 + maxgens)), 0:maxgens, sep = \"_\")\n\n# Weight the NumGen raster bricks for each generation according to the relative\n# population size of each cohort. For example, cohort 1 emerged sooner in\n# the year so may have completed more generations, but they comprise a small\n# proportion of the population. The result of the analysis will depict this.\nRegCluster(round(ncores/10))\nforeach(i = 1:length(gen_fls_lst), .packages = pkgs, \n                          .inorder = TRUE) %dopar% {\n#for (i in 1:length(gen_fls_lst)) { \n  # Which generation number?\n  gen_nam <- names(gen_fls_lst)[i]\n  gen <- as.numeric(str_split_fixed(gen_nam, \"_\", 2)[,2])\n  gen_cohort_fls <- unlist(unname(gen_fls_lst[i]))\n  # The value is NA here, becaue the raster bricks have already been split out\n  # by generation (as opposed to the Lifestage bricks needing to be split \n  # by stage).\n  NumGen_wtd <- Weight_rasts(gen_cohort_fls, \"NumGen\")\n  SaveRaster2(NumGen_wtd, paste(\"Misc_output/Gen\", gen, sep = \"_\"), \"INT2U\", \n               paste(\"- Gen.\", gen, \"for all\", num_dats, \"dates\"))\n  #cat(\"Finished NumGen_wtd\", gen, \"\\n\")\n  \n  # As for the Lifestage results, it is more memory efficient to overlay the\n  # All Stress Exclusion raster with the weighted NumGen brick than to weight\n  # the NumGenEXCL1 and NumGenEXCL2 files separately.\n  if (exclusions_stressunits) {\n    NumGen_wtd_excl1 <- do.call(brick, Rast_Subs_Excl(NumGen_wtd, \"Excl1\"))\n    SaveRaster2(NumGen_wtd_excl1,\n                paste(\"Misc_output/GenExcl1\", gen, sep = \"_\"), \"INT2S\",\n                str_wrap(paste(\"- Gen.\", gen,\n                               \"with severe climate stress excl. for all\",\n                               num_dats, \"dates\"), width = 80))\n    rm(NumGen_wtd_excl1) # Free memory\n       \n    #cat(\"Finished NumGen_wtd_excl1 - gen\", gen, \"\\n\")\n       \n    NumGen_wtd_excl2 <- do.call(brick, Rast_Subs_Excl(NumGen_wtd, \"Excl2\"))\n    rm(NumGen_wtd) # Free up memory\n    SaveRaster2(NumGen_wtd_excl2,\n                paste(\"Misc_output/GenExcl2\", gen, sep = \"_\"), \"INT2S\",\n                str_wrap(paste(\"- Gen.\", gen,\n                \"with severe and moderate climate stress excl. for all\",\n                num_dats, \"dates\"), width = 80))\n    rm(NumGen_wtd_excl2)\n    cat(\"Finished NumGen_wtd_excl2 - gen\", gen, \"\\n\")\n  }\n\n}\n\nstopCluster(cl)\nrm(cl)\n\n# Delete cohort raster bricks split by generation - no longer needed\nunlink(list.files(pattern = glob2rx(paste0(\"*Gen_*cohort*\"))))\n\n### * Create summary maps of NumGen results, weighted across cohorts\n\n# Log file messages\nif (exclusions_stressunits) {\n  cat(\"\\n\\n\", str_wrap(\"Done with weighted raster outputs for \n                       NumGen, NumGen_Excl1, and NumGen_Excl2\", width = 80),\n      sep = \"\", file = Model_rlogging, append = TRUE) \n  cat(\"\\n\\n### SUMMARY MAP OUTPUT: NUMGEN WITH CLIMATE STRESS EXCLUSIONS ###\", \n      file = Model_rlogging, append = TRUE)\n  cat(\"\\n\", str_wrap(\"Done with weighted raster outputs for NumGen, \n      NumGen_Excl1, and NumGen_Excl2\", width = 80), sep = \"\")\n  cat(\"\\n\\nSUMMARY MAP OUTPUT: NUMGEN WITH CLIMATE STRESS EXCLUSIONS\\n\")\n} else {\n  cat(\"\\n\\nDone with weighted raster outputs for NumGen\", \n      file = Model_rlogging, append = TRUE) \n  cat(\"\\n\\n### SUMMARY MAP OUTPUT: NUMGEN ###\", \n      file = Model_rlogging, append = TRUE)\n  cat(\"\\nDone with weighted raster outputs for NumGen\\n\")\n  cat(\"\\nSUMMARY MAP OUTPUT: NUMGEN\\n\", sep = \"\")\n}\n\nif (odd_gen_map == 1) {\n  cat(\"\\n\\nPlotting odd generations only\", file = Model_rlogging, \n      append = TRUE) \n}\n\n# For each type (NumGen, NumGenExcl1, and NumGenExcl2, stack all generations \n# together, and then save the stack to a file. This allows the stacked results \n# to be worked with outside of the program, freeing up memory. First a list of \n# files to stack is created (by type), then the stacked files are written to \n# file. Writing the files is done in parallel if exclusions_stressunits = 1 \n# (NumGenExcl1 and NumGenExcl2); otherwise the process is very, very slow.\n\n# Make the list of files to stack by type\nfls_to_stack <- list(list.files(paste0(getwd(), \"/Misc_output\"), \n                           pattern = glob2rx(\"*Gen_*.tif$\")))\n\nif (exclusions_stressunits) {\n  fls_to_stack <-  append(fls_to_stack, \n                         list(list.files(paste0(getwd(), \"/Misc_output\"), \n                                    pattern = glob2rx(\"*GenExcl1_*.tif$\")),\n                         list.files(paste0(getwd(), \"/Misc_output\"), \n                                 pattern = glob2rx(\"*GenExcl2_*.tif$\"))))\n  names(fls_to_stack) <- c(\"NumGen\", \"NumGenExcl1\", \"NumGenExcl2\")\n} else {\n names(fls_to_stack) <- c(\"NumGen\")\n}\n\n# Add directory (\"Misc_output/\") to every element in the list\nfls_to_stack[] <- lapply(fls_to_stack, function(x) paste0(\"Misc_output/\", x))\n\n# For each type (NumGen, NumGenExcl1, NumGenExcl2), stack all \n# generations together and write the results to file\nif (exclusions_stressunits) {\n  RegCluster(round(ncores/10))\n\n  foreach(i = 1:length(fls_to_stack), .packages = pkgs,\n          .inorder = TRUE) %dopar% {\n    fl_type <- names(fls_to_stack[i])\n    writeRaster(stack(unlist(fls_to_stack[i], use.names = FALSE)),\n              filename = paste0(fl_type, \"_all_merged.grd\"))\n  }\n\n  stopCluster(cl)\n  rm(cl)\n\n} else {\n  writeRaster(stack(unlist(fls_to_stack, use.names = FALSE)),\n              filename = \"NumGen_all_merged.grd\")\n}\n\n# Summary maps will be produced for each generation (saved from previous step), \n# for each date. This involves looping through all dates, creating\n# a dataframe that contains data from all generations for a given date, and \n# plotting the results. This is done in parallel for increased speed [by data\n# and by type (NumGen, NumGenExcl1, and NumGenExcl2)].\nNumGen_mrgd_fls <- list(\"NumGen_all_merged.grd\")\nif (exclusions_stressunits) {\n  NumGen_mrgd_fls <- append(NumGen_mrgd_fls, \n                            list(\"NumGenExcl1_all_merged.grd\",\n                                 \"NumGenExcl2_all_merged.grd\"))\n}\n\nRegCluster(round(ncores/4))\n\n#for (i in 1:length(NumGen_mrgd_fls)) {\nforeach(i = 1:length(NumGen_mrgd_fls), .packages = pkgs,\n     .inorder = TRUE) %:%\n  foreach(d = dats_list, .packages = pkgs, .inorder = TRUE) %dopar% {\n    \n    # Get the brick for the file type\n    brk_fl <- NumGen_mrgd_fls[[i]]\n    fl_type <- names(brick(NumGen_mrgd_fls[[i]])[[1]])\n    fl_type <- str_split_fixed(fl_type, pattern = \"_\", 2)[,1]\n    \n    #for (d in dats_list) { \n    #print(d)\n    \n    # Create a vector of dates from each chunk in the dates list\n    # Then loop through date vector, extract (subset) the raster brick for the\n    # file type by a given date, and then create a data frame that has all data\n    # from all generations for that date.\n    dat_vec <- unname(unlist(d))\n    for (dat in dat_vec) {\n      #print(dat)\n      # Which layer # in the stack corresponds to the date? Then subset brick.\n      lyr_no <- which(dats2 == dat) \n      lyr_name <- paste0(\"\\\\b[.]\", lyr_no, \"\\\\b\") # exact match\n      brk_sub <- brick(brk_fl)[[grep(lyr_name, names(brick(brk_fl)))]]\n      \n      # In order for all completed generations to show up in legend key,\n      # need to extract info from \"NumGen_all_merged\" brick for the date -\n      # the climate stress values mask out this information. (TO DO: figure\n      # out a way to avoid this in earlier steps?)\n      # If a generation has completed or currently present, then there will be\n      # non-zero values.\n      if (exclusions_stressunits) {\n        NumGen_brk <- brick(NumGen_mrgd_fls[[1]])\n        brk_sub2 <- NumGen_brk[[grep(lyr_name, names(NumGen_brk))]]\n        maxgens <- data.frame(as(brk_sub2, \"SpatialPixelsDataFrame\")) %>%\n          dplyr::select(-x, -y) %>% \n          gather() %>% # Combine columns and make column of generation data\n          mutate(gen = str_split_fixed(key, pattern = \"_\", 2)[,2]) %>% \n          mutate(gen = sub('\\\\..*', '', gen)) %>%\n          filter(value > 0) %>% # Remove 0 values (gens not present)\n          distinct(gen) %>% arrange %>% # Returns the gen(s) present on date\n          pull() %>% last()\n        maxgens <- as.numeric(maxgens) # This will be incorporated below\n      }\n        \n      # Convert each layer of raster brick to a data frame; add generation num.\n      # The add each data frame to a list; these will be merged below.\n      NumGen_lyrs_toPlot <- list()\n      #j <- 1\n      for (lyr in 1:nlayers(brk_sub)) {\n        df <- ConvDF(brk_sub[[lyr]])\n        # Extract generation number from layers for that date\n        lyr_name <- sub('\\\\..*', '', names(brk_sub[[lyr]]))\n        gen <- str_split_fixed(lyr_name, pattern = \"_\", 2)[,2]\n        df$gen <- as.numeric(sub(\"*\\\\.[0-9]\", \"\", gen))\n\n        # Don't include data if all values are >= 0 - don't want them to be \n        # in legend key\n        if (any(df$value > 0)) {\n          NumGen_lyrs_toPlot[[lyr]] <- df\n        }\n        \n      }\n      \n      # Format data if pops of NO gens are present (no value > 0) AND there are \n      # climate stress exclusions - i.e. the spp is excluded from entire area. \n      # Then take the last data frame in the list; the generation column will \n      # be replaced with simply \"excl. severe\" and/or \"excl. moderate\" in plot.\n      # Don't want to show generation in legend (b/c all would be excluded); \n      # just show \"excl. severe\" and/or \"excl. moderate\"\n      brk_sub_uniqueVals <- unique(\n        c(as.matrix(brk_sub)))[!is.na(unique(c(as.matrix(brk_sub))))]\n      \n      if (all(brk_sub_uniqueVals < 0)) {\n        mrgd2 <- df\n      }\n      \n      # Merge data frames in the list - if list is empty b/c all data frames \n      # had value = 0, then just use most recent data frame\n      if (any(brk_sub_uniqueVals > -1) & length(NumGen_lyrs_toPlot) > 0) {\n        mrgd <- do.call(rbind, NumGen_lyrs_toPlot)\n      } else {\n        mrgd <- df\n      }\n      \n      rm(NumGen_lyrs_toPlot) # Free up memory\n      \n      # Create a layer for OW generation, using dataframe from latest \n      # generation, if present in data\n      if (any(brk_sub_uniqueVals > -1) & any(mrgd$gen == 0)) {\n        OW <- data.frame(mrgd %>% dplyr::filter(gen == 0))\n      }\n      \n      # From merged data frame, remove duplicate cells, showing the most \n      # recent generation in cases of overlap\n      if (any(brk_sub_uniqueVals > -1) & any(mrgd$value > 0)) {\n        noZero <- data.frame(mrgd %>% group_by(x, y) %>% arrange(gen))\n        noZero <- dplyr::filter(noZero, !value == 0)\n        if (any(mrgd$gen == 0)) { \n          mrgd2 <- rbind(OW, noZero) \n        } else {\n          mrgd2 <- noZero\n        }\n        \n        # Format data if pops of any gen are present (value > 0) AND there are \n        # climate stress exclusions, but first check that there are any values \n        # in data >= 0 (if all values < 0, data are handled differently above)\n      } else if (any(brk_sub_uniqueVals > 0) & any(mrgd$value < 0)) {\n        if (any(mrgd$value < 0)) {\n          excl_vals <- data.frame(mrgd %>% dplyr::filter(value != 0))\n          #excl_vals$gen <- \"GenOW\"\n          if (any(df$gen == 0)) {\n            mrgd2 <- rbind(excl_vals, OW) \n          } else {\n            mrgd2 <- excl_vals\n          }\n        } else {\n          mrgd2 <- OW\n        }\n      }\n      \n      # If specified, create summary maps for odd generations only (1, 3, 5, ..)\n      # ISSUE: no generations will be available to plot if even gens only are\n      # present on a given date! This feature is therefore not useful on small\n      # scales, since many gens may be missing at that scale.\n      if (odd_gen_map == 1 & any(mrgd2$gen > 0)) {\n        mrgd2 <- mrgd2[(mrgd2$gen %% 2 != 0),]\n      }\n      \n      # If the input data are the files with climate stress values, then\n      # the completed number of gens as computed above need to be added back in \n      if (i %in% c(2, 3)) {\n        mrgd2 <- mrgd2 %>% \n          add_row(gen = 0:maxgens, value = 0) %>%\n          mutate(gen = ifelse(value == -1, -1, ifelse(value == -2, -2, gen)))\n      }\n        \n      # Plot results as long as there are data in \"mrgd2\" - this data frame\n      # will be empty only if \"odd_gen_map == 1,\" and there are no data for \n      # Gen1, Gen3, ... etc. (e.g., if there are only data for GenOW, which \n      # has been removed)\n      if (nrow(mrgd2) > 0) {\n        # Create and save summary maps\n        if (fl_type == \"GenExcl1\") {\n          PlotMap(mrgd2, dat, \n                  \"Number of generations w/ climate stress exclusions\",\n                  \"No. of\\ngenerations\", \"NumGen_Excl1\")\n        } else if (fl_type == \"GenExcl2\") {\n          PlotMap(mrgd2, dat, \n                  \"Number of generations w/ climate stress exclusions\",\n                  \"No. of\\ngenerations\", \"NumGen_Excl2\")\n        } else if (fl_type == \"Gen\") {\n          PlotMap(mrgd2, dat, \"Number of generations\", \n                  \"No. of\\ngenerations\", \"NumGen\")\n        }\n      } else {\n        cat(\"\\n\\nWARNING: NumGen results for\", fl_type, \"on\", dat, \n            \"\\nnot plotted - no odd generation data for this date\", \n            file = Model_rlogging, append = TRUE)\n      }\n    }\n  }\n#}\n\nstopCluster(cl)\nrm(cl)\n\n# Log file messages\nif (exclusions_stressunits) {\n  cat(\"\\n\\n\", str_wrap(\"Done with summary maps for NumGen, NumGen_Excl1, and \n                       NumGen_Excl2\", width = 80), sep = \"\", \n      file = Model_rlogging, append = TRUE) \n  cat(\"\\n\\n\", str_wrap(\"### ANALYSIS: LIFESTAGE W/ NO. OF GENS. AND CLIMATE \n                       STRESS EXCLUSIONS ###\\n\", \n                       width = 80), sep = \"\", \n      file = Model_rlogging, append = TRUE)\n  cat(\"\\nDone with summary maps for NumGen, NumGen_Excl1, and NumGen_Excl2\\n\\n\")\n  cat(\"ANALYSIS: LIFESTAGE W/ NO. OF GENS. AND CLIMATE STRESS EXCLUSIONS\\n\\n\")\n} else {\n  cat(\"\\n\\nDone with summary maps for NumGen\", \n      file = Model_rlogging, append = TRUE) \n  cat(\"\\n\\n### ANALYSIS: LIFESTAGE WITH NUMBER OF GENS. ###\\n\", sep = \"\", \n      file = Model_rlogging, append = TRUE)\n  cat(\"\\nDone with summary maps for NumGen\\n\\n\", str_wrap(\"ANALYSIS: LIFESTAGE \n      WITH NUMBER OF GENS.\\n\\n\"), sep = \"\")\n}\n\n#### * Lifestage by generation analysis ####\n\n# NumGen layers may overlap at edges due to cohorts\n# Want to show later generations in case of overlap, or maps will show adults \n# that are assigned to the wrong generation. First make a vector of the various \n# generation combinations to deal w/ this overlap issue.\n# TO DO: find a more efficient way to overlay generation combos w/o several \n# lines of code here\n# Make vector of gen numbers\ngens_noOW <- 1:maxgens # remove OW generation\n\n# If more than 2 generations, split even and odd gens, make combos, and then \n# paste together\nif (length(gens_noOW) > 2) {\n  # Take every other gen no., starting with element 1 (odd), and again with \n  # element 2 (even)\n  gens_even <- gens_noOW[gens_noOW %% 2 == 0] # if divisible by 2, is even \n  gens_even <- paste(\"Gen\", gens_even, sep = \"_\")\n  gens_odd <- gens_noOW[gens_noOW %% 2 != 0] # if not divisible by 2, is odd\n  gens_odd <- paste(\"Gen\", gens_odd, sep = \"_\")\n  gens_odd2 <- gens_odd[2:length(gens_odd)]\n  # First combo - consecutive numbers starting at Gen1 \n  # (e.g. Gen_2|Gen_1, Gen_4|Gen_3...)\n  # If uneven no. of gens, need to trim odd and even to same length\n  if (length(gens_odd) > length(gens_even)) {\n    gens_combo1 <- paste(gens_even, gens_odd[1:length(gens_even)], sep = \"|\")\n  } else {\n    gens_combo1 <- paste(gens_even, gens_odd, sep = \"|\")\n  }\n  # Second combo - consecutive numbers starting at Gen2 \n  # (e.g., Gen_3|Gen_2, Gen_5|Gen_4)\n  gens_combo2 <- paste(gens_odd2, gens_even[1:length(gens_odd2)], sep = \"|\")\n  # Combine the two combo vectors and sort, then add on OW gen\n  gens_combo_all <- sort(c(gens_combo1, gens_combo2)) \n  gens_combo_all <- append(\"Gen_1|Gen_0\", gens_combo_all)\n  # If only two generations, then just make this combo\n  } else if (length(gens_noOW) == 2) {\n    gens_combo_all <- c(\"Gen_1|Gen_0\", \"Gen_2|Gen_1\")\n  # If only one generation, then make this combo\n  } else if (length(gens_noOW) == 1) {\n    gens_combo_all <- c(\"Gen_1|Gen_0\")\n}\n\n# For each combination, overlay the combos for each date and replace older \n# generation values (e.g., for combo \"NumGen_2|NumGen_1\" - NumGen_2 will replace \n# NumGen1 where there is overlap)\ncat(\"\\n\\n\", str_wrap(\"Replacing older generation vals with newer gen. \n                   vals in areas of overlap\", width = 80), \"\\n\", sep = \"\",\n    file = Model_rlogging, append = TRUE)\n\nRegCluster(round(ncores/10))\n  \ncorrected_NumGen <- foreach(d = 1:length(dats2), .packages = pkgs, \n                            .inorder = FALSE) %dopar% {\n#corrected_NumGen <- for (d in 1:length(dats2)) { \n  \n  # Get file and layer names\n  NumGen_all_fl <- \"NumGen_all_merged.grd\"\n  all_lyr_names <- names(brick(NumGen_all_fl))\n                               \n  corrected_brick_list <- list()\n  \n  for (i in 1:length(gens_combo_all)) {\n    \n    # Which layer # in the stack corresponds to the date? Then subset brick\n    # and replace all non-zero values w/ 1, and 0 values with NA\n    lyr_no <- which(dats2 == dats2[d]) \n    lyr_name <- paste0(\"\\\\b\", lyr_no, \"$\\\\b\") # regex for getting exact match\n    sub1 <- raster::stack(NumGen_all_fl)[[grep(lyr_name, all_lyr_names)]]\n    sub1[sub1 > 0] <- 1 \n    sub1[sub1 == 0] <- NA\n    \n    # Get each gen in the combo\n    genA <- str_split_fixed(gens_combo_all[i], pattern = \"\\\\|\", 2)[,1]\n    genB <- str_split_fixed(gens_combo_all[i], pattern = \"\\\\|\", 2)[,2]\n    \n    # Search for each of those gens in the stack and combine them\n    # The order matters here, genA must be first layer\n    sub1A <- raster::subset(sub1, grep(paste0(genA, \"[.]\"), names(sub1)))\n    sub1B <- raster::subset(sub1, grep(paste0(genB, \"[.]\"), names(sub1)))\n    sub2 <- raster::stack(sub1A, sub1B)\n    rm(sub1A, sub1B) # Free up memory\n    \n    # Identify areas where the two gens overlap by summing them\n    # Areas of overlap = 2\n    gen_ovlp <- stackApply(sub2, indices = c(1), fun = sum) \n    \n    # Crop the layer of the later generation if it overlaps w/ earlier one\n    # (but if values are all NA, just keep it)\n    if (!is.na(any(values(sub2[[2]] > 0)))) {\n      gen_ovlp_NA <- overlay(sub2[[1]], sub2[[2]], gen_ovlp,\n        fun = function(x, y, z) {\n          x[z == 2] <- NA\n          return(x) # Returns cropped layer of later generation\n        })\n      names(gen_ovlp_NA) <- names(sub2[[1]])\n    } else {\n       gen_ovlp_NA <- sub2[[1]]\n    }\n    \n    # Need to add the very first layer back in (should be NumGen0)\n    if (i == length(gens_combo_all)) {\n      gen0 <- sub1[[1]]\n      gen_ovlp_NA <- raster::stack(gen0, gen_ovlp_NA)\n    }\n    \n    # \"Corrected\" combo is put back into a list\n    corrected_brick_list[i] <- gen_ovlp_NA \n  }\n    \n  # Create a raster stack from the list\n  NumGen_corrected <- do.call(stack, corrected_brick_list)\n    \n}\n\n# Combine results of the previous analysis and overwrite the \n# \"NumGen_all_merged.grd\" file. This raster file has the \"corrected\" layers.\n# Alternatively the above output can be held in memory as a huge raster\n# stack. The run times are essentially the same, but will use this method\n# instead in case there may be memory issues.\nwriteRaster(do.call(stack, corrected_NumGen),\n  filename = \"NumGen_all_merged.grd\", overwrite = TRUE)\n\nrm(corrected_NumGen)  # Free up memory                           \n\n# All done - print messages and stop clusters  \ncat(\"Done\\n\", file = Model_rlogging, append = TRUE)\ncat(\"\\nDone\\n\")\n  \nstopCluster(cl)\nrm(cl)\n\n# Now use resulting ordered NumGen brick layers to mask out Lifestage \n# (adult) layers. These will be plotted so that the Lifestage (adult) for each\n# generation is depicted with a distinct color.\nif (exclusions_stressunits) {\n  cat(\"\\n\", str_wrap(\"Assigning a generation number to pixels in the Adult, \n                   Adult_Excl1, and Adult_Excl2 raster bricks\", width = 80), \n      sep = \"\", file = Model_rlogging, append = TRUE)\n  cat(\"\\n\", str_wrap(\"Assigning a generation number to pixels in the Adult, \n                   Adult_Excl1, and Adult_Excl2 raster bricks\", width = 80),\n      sep = \"\")\n} else {\n  cat(\"\\n\", str_wrap(\"Assigning a generation number to pixels in the Adult \n                     raster brick\", width = 80), sep = \"\", \n      file = Model_rlogging, append = TRUE)\n  cat(\"\\n\", str_wrap(\"Assigning a generation number to pixels in the Adult \n                     raster brick\", width = 80), sep = \"\")\n}\n\n# Subset NumGen raster stack by generation and then mask out areas in weighted\n# Adult rasters that do not belong to that generation \n# Result will be a list of raster stacks for each generation of adults\n\n# Get raster bricks for adults; if climate stress is turned on, then\n# there will be three bricks to analyze\nif (exclusions_stressunits) {\n  Adult_fl_types <- c(\"Adult\", \"Adult_Excl1\", \"Adult_Excl2\")\n} else {\n  Adult_fl_types <- c(\"Adult\")\n}\n  \nRegCluster(round(ncores/10))\n\n# Run the overlay analysis and save results as raster bricks\n#for (type in Adult_fl_types) {\nforeach(type = Adult_fl_types, .packages = pkgs, \n                        .inorder = TRUE) %:%\n  foreach(gen = 0:maxgens, .packages = pkgs, .inorder = TRUE) %dopar% {\n  #print(type)\n    #for (gen in 0:maxgens) {\n    #  print(gen)\n    # Extract data for each generation\n    NumGen_msk <- raster::subset(brick(\"NumGen_all_merged.grd\"),\n    grep(paste0(\"Gen_\", gen, \"[.]\"),\n         names(brick(\"NumGen_all_merged.grd\"))))\n    \n    # Mask out areas in adults raster that do not belong to the gen. of interest\n    # Then name each layer by the generation no. and the date\n    file_name <- paste0(\"Misc_output/\", type, \".tif\")\n  \n    Adults_byGen <- overlay(brick(file_name), NumGen_msk, \n      fun = function(x, y) {\n        x[is.na(y[])] <- NA\n        names(x) <- names(y)\n        return(x)\n    }, datatype = \"INT2S\", filename = paste0(type, \"_Gen\", gen, \".tif\"))\n    names(Adults_byGen) <- paste(\"Gen\", gen, dats2, sep = \"_\")\n  }\n#}\n\nstopCluster(cl)\nrm(cl)\n\n# All done - print messages and stop clusters  \ncat(\"\\nDone\\n\", file = Model_rlogging, append = TRUE)\ncat(\"\\nDone\")\n  \n# Delete NumGen grids now that they are no longer needed\nunlink(list.files(pattern = glob2rx(paste0(\"*.gri$|*.grd$\"))))\n\n#### * Life stage with no. of generations plots ####\nif (exclusions_stressunits) {\n  cat(\"\\nDone with Lifestage with NumGen analysis\\n\\n\", \n      str_wrap(\"### SUMMARY MAP OUTPUT: LIFESTAGE W/ NO. OF GENS AND CLIMATE \n               STRESS EXCL.\", width = 80), \" ###\", sep = \"\",\n      file = Model_rlogging, append = TRUE)\n  cat(\"\\n\\nDone with Lifestage with NumGen analysis\\n\\n\", \n      str_wrap(\"SUMMARY MAP OUTPUT: LIFESTAGE W/ NO. OF GENS AND CLIMATE STRESS \n               EXCL.\\n\", width = 80), \"\\n\", sep = \"\")\n} else {\n  cat(\"\\n\\n### SUMMARY MAP OUTPUT: LIFESTAGE W/ NO. OF GENS. ###\", sep = \"\",\n      file = Model_rlogging, append = TRUE)\n  cat(\"\\n\\nDone with Lifestage with NumGen analysis\\n\\n\", \n      str_wrap(\"SUMMARY MAP OUTPUT: LIFESTAGE W/ NO. OF GENS.\\n\", width = 80), \n      \"\\n\", sep = \"\")\n}\n\n# Get files to plot\nif (exclusions_stressunits) {\n  Adult_byGen_fls <-  list(list.files(pattern = glob2rx(\"*Adult_Gen*.tif$\")), \n    list.files(pattern = glob2rx(\"*Adult_Excl1_Gen*.tif$\")), \n    list.files(pattern = glob2rx(\"*Adult_Excl2_Gen*.tif$\")))\n  names(Adult_byGen_fls) <- c(\"Adult\", \"Adult_Excl1\", \"Adult_Excl2\")\n} else {\n  Adult_byGen_fls <- list(list.files(pattern = glob2rx(\"*Adult_Gen*.tif$\")))\n  names(Adult_byGen_fls) <- c(\"Adult\")\n}\n\n# Generate and save summary plots for \"Lifestage by Generation\" (currently only\n# doing these for adults). TO DO: maybe change way the results are displayed; \n# a bit confusing to have \"other stages\" plus gen number, but gen number is \n# not actually dispalyed on map.\nRegCluster(round(ncores/6))\n\nAdult_byGen_sum_maps <- foreach(j = 1:length(Adult_byGen_fls), \n .packages = pkgs, .inorder = TRUE) %:% \n  foreach(d = dats2, .packages = pkgs, .inorder = TRUE) %dopar% {\n\n#for (j in 1:length(Adult_byGen_fls)) {\n fl_type <- paste0(names(Adult_byGen_fls[j]))\n # for (d in dats2) {\n   #print(d)\n    #print(j)\n\n    # Which layer # in the stack corresponds to the date? \n    lyr_no <- which(dats2 == d) \n    lyr_name <- paste0(\"\\\\b\", lyr_no, \"$\\\\b\") # regex for getting exact match\n    \n    # Subset the brick by the layer name\n    fls <- Adult_byGen_fls[[j]]\n    brk_sub <- brick()\n    for (f in 1:length(fls)) {\n      brk <- brick(fls[[f]])[[grep(lyr_name, names(brick(fls[[f]])))]]\n      brk_sub <- addLayer(brk_sub, brk)\n      #print(f)\n    }\n    \n    # For each stack layer, identify the generation, convert data to a \n    # data frame and add it to a list\n    df_list <- list()\n    for (i in 1:nlayers(brk_sub)) {\n      r <- brk_sub[[i]]\n      gen <- unlist(str_split(names(r), paste0(\"_Gen|[.]\")))[2]\n      #print(gen)\n      \n      # Only convert raster to data frame if any values are not NA \n      # and either greater than 0 or less than 0 (less than 0 indicates climate \n      # stress exclusions). Note that output maps may have a generation in \n      # the legend that is not visible on the map - this is because other \n      # life stages (in light gray) are present, not the adults.\n      # TO DO: maybe figure out a better way to show this.\n      if (any(values(r) >= 0 & !is.na(values(r))) | \n          any(values(r) < 0 & !is.na(values(r)))) {\n        lyr_df <- ConvDF(r) # convert raster to a data frame\n        lyr_df$gen <- as.numeric(gen)\n        colnames(lyr_df)[1] <- \"value\"\n        df_list[[i]] <- lyr_df # add to the list \n      }\n    }\n    \n    # Merge the list into a single data frame - this has data from all \n    # generations for a given date. Remove generations for which all values \n    # are 0, otherwise will obscure data from other layers (other gens)\n    # Not doing this will produce erroneous bands of adults at southern edge\n    mrgd <- do.call(rbind, df_list) \n    \n    # Free up memory\n    rm(df_list, brk_sub, r)\n    \n    # Optional: create summary maps for odd generations only - beginning for \n    # 1st gen (i.e., 1, 3, 5, ..)\n    if (odd_gen_map == 1) { # should odd gens be plotted instead of all gens?\n     mrgd <- mrgd[(mrgd$gen %% 2 != 0),]\n    }\n    \n    # Plot results as long as there are data in \"mrgd2\" - this data frame will \n    # be empty only if \"odd_gen_map == 1\" and there are no data for Gen1, Gen3, \n    # ... etc. (e.g., if there are only data for GenOW, which has been removed)\n    # Currently \"other stages\" (not adults) are colored gray - may want to \n    # consider coloring them more similarly to which generation they belong to\n    if (nrow(mrgd) > 0) {\n      if (fl_type == \"Adult\") {\n        PlotMap(mrgd, d, \"Adult relative pop. size for each gen.\", \n                \"Adult relative\\npop. size (peak)\", \"Misc_output/Adult_byGen\")\n        } else if (fl_type == \"Adult_Excl1\") {\n          PlotMap(mrgd, d, \n          \"Adult relative pop. size for each gen. w/ climate stress exclusion\",\n                  \"Adult relative\\npop. size (peak)\", \n                  \"Misc_output/Adult_Excl1_byGen\")\n        } else if (fl_type == \"Adult_Excl2\") {\n          PlotMap(mrgd, d, \n          \"Adult relative pop. size for each gen. w/ climate stress exclusion\",\n                  \"Adult relative\\npop. size (peak)\", \n                  \"Misc_output/Adult_Excl2_byGen\")\n      }\n    } else {\n      cat(\"\\n\\nWARNING: Adult w/ NumGen results for each gen. on\", d, \n          \"\\nnot plotted - no odd generation data for this date\", \n          file = Model_rlogging, append = TRUE)\n    }\n  }\n#}\n\nstopCluster(cl)\nrm(cl)\n\n# Delete temp files \nunlink(list.files(pattern = glob2rx(paste0(\"*Adult*Gen*.tif$\"))))\n\ncat(\"\\n\\nDone with Lifestage with NumGen summary maps\\n\", \n    file = Model_rlogging, append = TRUE)\ncat(\"\\nDone with Lifestage with NumGen summary maps\\n\")\n\n#### * Analyses and map production all done - wrap-up ####\nprocessing_exectime <- toc(quiet = TRUE)\nprocessing_exectime <- (processing_exectime$toc - processing_exectime$tic) / 60 \n\ncat(\"\\n### Done w/ final analyses and map production ###\\n\", \n    \"Run time for analyses and map production = \", \n    round(processing_exectime, digits = 2), \" min\\n\", sep = \"\", \n    \"Deleting, renaming, and moving miscellaneous files\\n\",\n    file = Model_rlogging, append = TRUE)\ncat(\"\\nDone w/ final analyses and map production\\n\\n\", \n    \"Run time for analyses and mapping run time = \", \n    round(processing_exectime, digits = 2),\n    \" min\\n\\n\", \"Deleting, renaming, and moving miscellaneous files\\n\\n\", \n    sep = \"\")\n\n#### * Rename final files and move misc files ####\n\n# Create list of files that will be kept in the main output folder. These \n# include outputs for the last day of the sampled time period, with the \n# exception of Stage Count outputs.\nlast_dat_fls <- list.files(pattern = glob2rx(paste0(\"*\", last(dats2), \n                                                    \"*.png$\")))\nstgCnt_remove <- grep(pattern = glob2rx(paste0(\"*StageCount*\", last(dats2), \n                                              \"*\")), last_dat_fls, value = TRUE)\nlast_dat_fls <- last_dat_fls[!last_dat_fls %in% stgCnt_remove]\n\n# If current year was sampled then keep Stage Count outfile for the current day \n# in the main output folder. Then make a list of final output files to rename.\nif (start_year == current_year) {\n  today_dat_fls <- list.files(pattern = glob2rx(paste0(\"*StageCount*\", \n                                                       today_dat, \"*.png$\")))\n  final_fls <- c(last_dat_fls, today_dat_fls)\n} else {\n  final_fls <- c(last_dat_fls)\n}\n\n# Put species abbreviation in final output files (rename)\nnew_names <- paste0(spp, \"_\", final_fls)\nif (length(final_fls) > 0) {\n  invisible(file.rename(final_fls, new_names))  \n} else {\n  cat(\"\\nNo PNG files for final outputs - check for errors\\n\", \n      file = Model_rlogging, append = TRUE)\n  cat(\"\\nNo PNG files for final outputs - check for errors\\n\")\n}\n\ncat(\"Renamed all final PNG files to include \", spp, \" in file name\\n\", sep = \"\", \n    file = Model_rlogging, append = TRUE)\ncat(\"Renamed all final PNG files to include \", spp, \" in file name\\n\", sep = \"\")\n\n# All other misc files (w/out spp name in file name) are moved to \"/Misc_output\"\nmisc_fls <- grep(list.files(path = output_dir), \n                 pattern = spp, invert = TRUE, value = TRUE) \nmisc_fls <- misc_fls[!(misc_fls %in% c(\"Misc_output\", \"Logs_metadata\"))]\ninvisible(file.copy(misc_fls, paste0(output_dir, \"/Misc_output/\")))\ninvisible(file.remove(misc_fls))\n\n# Wrap up log file and report time for entire model run\ncat(\"\\nMODEL RUN DONE\\n\", file = Model_rlogging, append = TRUE)\ncat(\"\\nMODEL RUN DONE\\n\")\ntotal_exectime <- toc(quiet = TRUE) # Execution time for entire run\ntotal_exectime <- round((total_exectime$toc - total_exectime$tic) / 60, \n                        digits = 2)\ncat(\"Run time for entire model =\", total_exectime, \"min\", \n    file = Model_rlogging, append = TRUE)\ncat(\"\\nRun time for entire model =\", total_exectime, \"min\\n\\n\")\n\n# Clean up\nrm(list = ls(all.names = TRUE)) # Clear all objects including hidden objects\ngc()\n\n",
    "created" : 1597088019254.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4084488045",
    "id" : "74945C6F",
    "lastKnownWriteTime" : 1595906858,
    "last_content_update" : 1595906858,
    "path" : "/usr/local/dds/DDRP_B1/ddrp_v2/DDRP_v2.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}