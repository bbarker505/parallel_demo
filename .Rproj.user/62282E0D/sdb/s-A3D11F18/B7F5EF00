{
    "collab_server" : "",
    "contents" : "# Functions used for DDRP_v2.R -----\n# \n# This file must accompany DDRP_v2.R; it contains the majority of functions \n# needed to run the program.\n# \n# Log of most recent changes -----\n# 7/22/20: Minor edits to RegCluster function\n# 7/16/20: Improved some legend colors to better discern categories\n# 6/26/20: Added \"StageCount\" summary maps, improved map legends, cleaned\n# up PlotMap function\n# 4/24/20: Changed the parameter name \"chill stress\" to \"cold stress\"\n# 3/31/20: Fixed issue w/ PEMs showing Dec of previous year\n# 2/25/20: Minor edits to PEM legend colors so weeks of year are always \n# assigned the same color\n# 2/18/20: Changed RegCluster back from FORK (to default = PSOCK) due to\n# apparent issues on Hopper (cannot open connection issues whenever the\n# process required access to numerous raster files). Updated Cut_interval func.\n# 2/15/20: Removed EXCl1 and EXCL2 steps for NumGen and Lifestage in \n# Daily Loop function because those raster bricks are not used - it is more\n# memory efficient to calculate them in the Data Processing section\n# 2/12/20: streamlined Rast_Subs_Excl functions; added Weight_rasts function\n# 2/7/20: fixed minor bugs in PlotMap function & changed a color\n# 1/28/20: detect CRS from template data, not hard-code it\n# 1/23/20: changed RegCluster func; fixed memory issues\n# 1/3/20: changed naming of clim. suit. output files\n# 12/9/19: had to fix code in PEM plotting - error for some spp\n#\n# Issues to resolve: boundary of CONUS doesn't line up completely with raster\n# May not be an issue, but the color key in PEMs is really convoluted - should\n# look into simplifying the code if possible.\n\n#### (1). Assign_extent: assign geographic extent ####\n# Add new extent definitions here for use in models and plots\n# Set up regions\n# Use switch() (works like a single use hash) \nAssign_extent <- function(region_param = paste0(region_param)) {\n  REGION <- switch(region_param,\n                \"CONUS\"        = extent(-125.0, -66.5, 24.54, 49.4),\n                \"WEST\"         = extent(-125.0, -102, 31.1892, 49.4),\n                \"EAST\"         = extent(-106.8, -66.5, 24.54, 49.4),\n                \"MIDWEST\"      = extent(-104.2, -87, 30, 49.3),\n                \"NORTHWEST\"    = extent(-125.1, -103.8, 40.6, 49.15),\n                \"SOUTHWEST\"    = extent(-124.6, -101.5, 31.2, 42.3),\n                \"SOUTHCENTRAL\" = extent(-83.6, -78.3, 31.8, 35.3),\n                \"NORTHCENTRAL\" = extent(-104.3, -80.2, 35.7, 49.4),\n                \"SOUTHEAST\"    = extent(-107.1, -75.0, 24.54, 39.6),\n                \"NORTHEAST\"    = extent(-84.2, -64.3, 36.9, 48.1),\n                \"AL\"           = extent(-88.5294, -84.7506, 30.1186, 35.1911),\n                \"AR\"           = extent(-94.8878, -89.5094, 32.8796, 36.6936),\n                \"AZ\"           = extent(-115, -108.98, 31.2, 37),\n                \"CA\"           = extent(-124.6211, -113.7428, 32.2978, 42.2931),\n                \"CO\"           = extent(-109.2625, -101.8625, 36.7461, 41.2214),\n                \"CT\"           = extent(-73.7700, -71.7870, 40.9529, 42.0355),\n                \"DL\"           = extent(-76.1392, -74.1761, 38.3508, 39.9919),\n                \"FL\"           = extent(-87.8064, -79.9003, 24.54, 31.1214),\n                \"GA\"           = extent(-85.7850, -80.5917, 30.1767, 35.1594),\n                \"IA\"           = extent(-96.8617, -89.9697, 40.1147, 43.7353),\n                \"ID\"           = extent(-117.3917, -110.6167, 41.4500, 49.15),\n                \"IL\"           = extent(-91.5897, -87.0461, 36.8903, 42.6375),\n                \"IN\"           = extent(-88.1686, -84.4686, 37.7836, 41.9794),\n                \"KS\"           = extent(-102.3342, -94.1756, 36.6369, 40.2836),\n                \"KY\"           = extent(-89.3581, -81.8425, 36.4208, 39.3347),\n                \"LA\"           = extent(-94.3019, -88.7758, 28.8333, 33.2994),\n                \"MA\"           = extent(-73.5639, -69.7961, 41.1689, 42.9525),\n                \"MD\"           = extent(-79.7014, -74.8833, 37.0631, 39.9075),\n                \"ME\"           = extent(-71.4056, -66.6667, 42.9525, 47.5228),\n                \"MI\"           = extent(-90.5542, -82.3047, 41.6311, 47.5739),\n                \"MN\"           = extent(-97.4000, -89.3786, 43.2550, 49.4),\n                \"MO\"           = extent(-95.8803, -88.9883, 35.8822, 40.7058),\n                \"MS\"           = extent(-91.7475, -87.8522, 29.9842, 35.2631),\n                \"MT\"           = extent(-116.3667, -103.8250, 44.0667, 49.15),\n                \"NC\"           = extent(-84.44092, -75.3003, 33.6829, 36.6461),\n                \"ND\"           = extent(-104.2708, -96.3075, 45.6403, 49.15),\n                \"NE\"           = extent(-104.3553, -95.0464, 39.7506, 43.2022),\n                \"NH\"           = extent(-72.6617, -70.6142, 42.6256, 45.4700),\n                \"NJ\"           = extent(-75.9175, -73.1892, 38.8944, 41.5806),\n                \"NM\"           = extent(-109.2942, -102.6383, 31.1892, 37.2000),\n                \"NV\"           = extent(-120.3358, -113.6803, 34.7356, 42.2981),\n                \"NY\"           = extent(-80.0867, -71.7381, 40.4828, 45.1692),\n                \"OH\"           = extent(-85.0439, -80.2464, 38.2797, 42.0217),\n                \"OK\"           = extent(-103.2850, -94.1964, 33.3839, 37.2850),\n                \"OR\"           = extent(-124.7294, -116.2949, 41.7150, 46.4612),\n                \"PA\"           = extent(-80.7672, -74.5033, 39.4694, 42.5094),\n                \"RI\"           = extent(-71.8628, -71.1206, 41.1463, 42.0188),\n                \"SC\"           = extent(-83.6422, -78.3275, 31.8814, 35.3811),\n                \"SD\"           = extent(-104.3553, -96.0806, 42.3050, 46.2050),\n                \"TN\"           = extent(-90.3239, -81.5047, 34.5578, 37.1125),\n                \"TX\"           = extent(-107.1592, -93.2411, 25.8614, 36.7200),\n                \"UT\"           = extent(-114.2925, -108.7450, 36.7778, 42.2347),\n                \"VA\"           = extent(-83.8322, -75.6200, 36.3892, 39.7886),\n                \"VT\"           = extent(-73.6747, -71.4108, 42.5886, 45.1956),\n                \"WA\"           = extent(-124.9585, -116.8364, 45.4554, 49.15),\n                \"WI\"           = extent(-93.1572, -86.6822, 42.2733, 46.9914),\n                \"WV\"           = extent(-82.8783, -77.5114, 37.1158, 40.7836),\n                \"WY\"           = extent(-111.6167, -103.7333, 40.6667, 45.4833))\n  return(REGION)\n}\n\n# autoStopCluster <- function(cl) {\n#   stopifnot(inherits(cl, \"cluster\"))\n#   env <- new.env()\n#   env$cluster <- cl\n#   attr(cl, \"gcMe\") <- env\n#   reg.finalizer(env, function(e) {\n#     message(\"Finalizing cluster ...\")\n#     #message(capture.output(print(e$cluster)))\n#     try(parallel::stopCluster(e$cluster), silent = FALSE)\n#     message(\"Finalizing cluster ... done\")\n#   })\n#   cl\n# }\n\n#### (2). Base_map: base map for summary plots ####\n# Base features used for all summary (PNG) maps in \"PlotMap\" function\n# The \"coord_quickmap\" function allows the state/region of interest to be \n# plotted (otherwise CONUS is plotted)\n# geom_raster is faster than geom_tile\n# Input data are in a data frame (= df) format\nBase_map <- function(df) {\n  p <- ggplot(states, aes(x = long, y = lat)) + \n    geom_raster(data = df, aes(x = x, y = y, fill = value)) + \n    geom_path(aes(group = group), color = \"black\", lwd = 0.4) +\n    #theme_map(base_size = base_size) +\n    coord_quickmap(xlim = c(REGION@xmin, REGION@xmax), \n                   ylim = c(REGION@ymin, REGION@ymax), expand = FALSE) \n    #coord_cartesian(xlim = c(REGION@xmin, REGION@xmax), \n    #ylim = c(REGION@ymin, REGION@ymax))\n}\n\n#### (3). CohortDistrib: cohort emergence distribution ####\n# This is an approximation from GAM predictions. \nCohortDistrib <- function(dist, numstage, perc) {\n    ReturnClosestValue <- function(dist, xval) {\n    out <- dist$CDF[which(dist$x > xval)[1]]\n  }\n  \n  low <- (1 - perc)/2\n  high <- 1 - (1 - perc) / 2\n  low <- dist$x[which(dist$CDF > low)[1]]\n  high <- dist$x[which(dist$CDF > high)[1]]\n  \n  bounds <- seq(low, high, length.out = numstage + 1)\n  means <- (bounds[1:numstage] + bounds[2:(numstage + 1)]) / 2\n  weights <- diff(sapply(X = bounds, FUN = ReturnClosestValue, dist = dist), \n                  lag = 1)\n  return(data.frame(means, weights))\n}\n\n#### (4). CombineMaps: merge raster tiles ####\n# Merge tiles back together for CONUS or EAST\n# SpaDES.tools requires 'sf' package (needs GDAL update), so just use \n# \"raster::merge\"\nCombineMaps <- function(brick_files, type, cohort) {\n  # Search for file type in brick file list\n  fls_by_type <- brick_files[grep(pattern = paste0(type, \"_\"), x = brick_files, \n                                  fixed = TRUE)]\n  # Merge tiles back together for the input cohort\n  fls_by_cohort <- fls_by_type[grep(pattern = paste0(\"cohort\", cohort), \n                                    x = fls_by_type, fixed = TRUE)]\n  mrgd <- Reduce(raster::merge, lapply(fls_by_cohort, brick))\n  #mrgd <- SpaDES.tools::mergeRaster(brk_by_cohort)\n  writeRaster(mrgd, filename = paste0(type, \"_cohort\", cohort, \"_all\"),\n              overwrite = TRUE, datatype = \"INT2S\", format = \"GTiff\")\n}\n\n#### (5). Cond: if then else (conditional) ####\n# If then else raster function [sim. to GRASS r.mapcalc if (x,a,b)]\nCond <- function(condition, trueValue, falseValue) {\n  return(condition * trueValue + (!condition) * falseValue)\n}\n\n#### (6). CohortVals: simple way to assign weights for substages (cohorts) ####\n# Choose number of substages (= numstage) and the decimal (0, 1) (= perc)\n# of population to include\n# Outputs standard deviations from mean and weights for substage\nCohortVals <- function(numstage, perc) {\n  low <- qnorm((1 - perc)/2)\n  high <- qnorm(1 - (1 - perc) / 2)\n  bounds <- seq(low, high, length.out = numstage + 1)\n  means <- (bounds[1:numstage] + bounds[2:(numstage + 1)]) / 2\n  weights <- diff(pnorm(bounds), lag = 1)\n  return(data.frame(means, weights))\n}\n\n#### (7). Colfunc: gradient color ramp for summary maps ####\n# Creates a gradient color ramp consisting of n colors\n# x and y are color1 and color2\nColfunc <- function(x, y, n) {\n  colorRampPalette(c(x, y))(n)\n}\n\n#### (8). ConvDF: convert raster to data frame ####\n# First convert raster (= rast) to a spatial pixels data frame and \n# then to a data frame\nConvDF <- function(rast) {\n  spdf <- as(rast, \"SpatialPixelsDataFrame\")\n  df <- as.data.frame(spdf)\n  colnames(df) <- c(\"value\", \"x\", \"y\")\n  return(df)\n}\n\n#### (9). Cut_bins: classify data into bins for plotting ####\n# Classify data (= df) so it can be visualized in categories \n# (e.g., 1-10, 11-20, 21-30) \nCut_bins <- function(df, breaks) {\n  df$value_orig <- df$value # Keep old value so can sort factors against it\n  # Round up max value to highest number divisible by 10\n  df$value[df$value == max(df$value)] <- 10 * ceiling(max(df$value)/10)\n  # Cut values into bins and format results\n  df2 <- df %>% mutate(value = cut_interval(df$value, n = breaks),\n            value = gsub(\"[()]|\\\\[|\\\\]\", \"\", value),\n            bin1 = ceiling(as.numeric(str_split_fixed(value, \",\", 2)[,1])),\n            bin2 = ceiling(as.numeric(str_split_fixed(value, \",\", 2)[,2])),\n            value = paste(bin1, bin2, sep = \"-\"))\n  return(df2)\n}\n\n# For data potentially ranging from 0 - 100 (Lifestage pop. size), \n# bins them by groups of 10 always starting at 0 and ending at 100.\n# TO DO: see about combining the two \"Cut_bin\" functions; simplify\nCut_bins2 <- function(df) {\n  df$value_orig <- df$value # Keep old value so can sort factors against it\n  df <- mutate(df, value = ifelse(value < 10, \"0-10\", \n          ifelse(value < 20, \"10-20\", ifelse(value < 30, \"20-30\", \n          ifelse(value < 40, \"30-40\", ifelse(value < 50, \"40-50\", \n          ifelse(value < 60, \"50-60\", ifelse(value < 70, \"60-70\", \n          ifelse(value < 80, \"70-80\", ifelse(value < 90, \"80-90\", \n          \"90-100\"))))))))))\n  return(df)\n}\n\n#### (10). DailyLoop: daily loop model ####\n# The daily loop is the daily time step used to generate all results for DDRP\n# The loop is run for each cohort (= cohort) in parallel. If the study region \n# is CONUS or EAST, then each of 4 tiles (= tile_num) are run in parallel as \n# well. The template (= template) is needed for setting up data sets to \n# populate during the model run, and to convert matrix outputs into raster \n# format.\nDailyLoop <- function(cohort, tile_num, template) { \n  \n  setwd(output_dir) \n  \n  # Generate a daily log file for each cohort - \n  # this is useful only for trouble-shooting\n  # if (region_param %in% c(\"CONUS\", \"EAST\")) {\n  #   daily_logFile <- paste0(\"Daily_loop_cohort\", cohort, \"_\", \n  #   tile_num, \".txt\")\n  # } else {\n  #   daily_logFile <- paste0(\"Daily_loop_cohort\", cohort, \".txt\")\n  # }\n  \n  #### * Initialize rasters for all variables ####\n  \n  # Main rasters - these are built upon within daily loop\n  DDaccum <- as.matrix(template)\n  # Track total degree days accumulated, for a single Lifestage (larvae)\n  DDtotal <- as.matrix(template)\n  # Track Lifestage for each cell per day (all cells start in OW = stage1)\n  Lifestage <- as.matrix(template) + 1\n  # Track voltinism per cell per day, starting at 0\n  NumGen <- as.matrix(template)\n  \n  # Additional rasters - created depending on input setting\n  if (exclusions_stressunits) {\n    # Create masks for each variable\n    coldmask         <- as.matrix(template)  # Daily cold units mask\n    coldstress       <- as.matrix(template)  # Count of daily cold units\n    coldstressTHRESH  <- as.matrix(template)  # Mask for coldstrs units thres\n    coldstressTHRESH  <- coldstress_threshold # Mask for coldstrs units thres\n    coldunitsCUM     <- as.matrix(template)  # Cumulative cold units\n    coldstressMAX1    <- as.matrix(template)  # Max cold before most die\n    coldstressMAX1    <- coldstress_units_max1 # Max cold before most die\n    coldstressMAX2    <- as.matrix(template)  # Max cold before all die\n    coldstressMAX2    <- coldstress_units_max2 # Max cold before all die\n    coldEXCL         <- as.matrix(template)  # Cold stress exclusion\n    heatmask          <- as.matrix(template)  # Daily heat stress units mask\n    heatstress        <- as.matrix(template)  # Count of daily heat stress units\n    heatstressTHRESH  <- as.matrix(template)  # Mask for heatstress units thres\n    heatstressTHRESH  <- heatstress_threshold # Mask for heatstress units thres\n    heatunitsCUM      <- as.matrix(template)  # Cumulative heat stress units\n    heatstressMAX1    <- as.matrix(template)  # Max heat before most die\n    heatstressMAX1    <- heatstress_units_max1 # Max heat before most die\n    heatstressMAX2    <- as.matrix(template)  # Max heat before all die\n    heatstressMAX2    <- heatstress_units_max2 # Max heat before all die\n    heatEXCL          <- as.matrix(template)  # Heat stress exclusions\n    AllEXCL           <- as.matrix(template)  # Combined stress exclusions\n  }\n  \n  if (pems) {\n    \n    if (mapE == 1 & eggEventDD) {  \n      # Event DD for all must be specified in spp.params file for this to run\n      if (PEMnumgens > 0) {\n        # Egg DOYs for when cumDDs > eggEvent threshold OW generation\n        PEMe0 <- as.matrix(template)  \n        # Egg DOYs for when cumDDs > eggEvent threshold  1st Gen\n        PEMe1 <- as.matrix(template)  \n      }\n      if (PEMnumgens > 1) {\n        # Egg DOYs for when cumDDs > eggEvent threshold  2nd Gen\n        PEMe2 <- as.matrix(template)  \n      }\n      if (PEMnumgens > 2) {\n        # Egg DOYs for when cumDDs > eggEvent threshold  3rd Gen\n        PEMe3 <- as.matrix(template)  \n      }\n      if (PEMnumgens > 3) {\n        # Egg DOYs for when cumDDs > eggEvent threshold  4th Gen\n        PEMe4 <- as.matrix(template)  \n      }\n    }\n    \n    if (mapL == 1 & larvaeEventDD) {\n       if (PEMnumgens > 0) {\n        # Larval DOYs for when cumDDs > larvaeEvent threshold OW generation\n        PEMl0 <- as.matrix(template)  \n        # Larval DOYs for when cumDDs > larvaeEvent threshold  1st Gen\n        PEMl1 <- as.matrix(template)  \n      }\n      if (PEMnumgens > 1) {\n        # Larval DOYs for when cumDDs > larvaeEvent threshold  2nd Gen\n        PEMl2 <- as.matrix(template)  \n      }\n      if (PEMnumgens > 2) {\n        # Larval DOYs for when cumDDs > larvaeEvent threshold  3rd Gen\n        PEMl3 <- as.matrix(template)  \n      }\n      if (PEMnumgens > 3) {\n        # Larval DOYs for when cumDDs > larvaeEvent threshold  4th Gen\n        PEMl4 <- as.matrix(template)  \n      }\n    }\n    \n    if (mapP == 1 & pupaeEventDD) {\n      if (PEMnumgens > 0) {\n        # Pupal DOYs for when cumDDs > pupalEvent threshold OW generation\n        PEMp0 <- as.matrix(template)  \n        # Pupal DOYs for when cumDDs > pupalEvent threshold  1st Gen\n        PEMp1 <- as.matrix(template)  \n      }\n      if (PEMnumgens > 1) {\n        # Pupal DOYs for when cumDDs > pupalEvent threshold  2nd Gen\n        PEMp2 <- as.matrix(template)  \n      }\n      if (PEMnumgens > 2) {\n        # Pupal DOYs for when cumDDs > pupalEvent threshold  3rd Gen\n        PEMp3 <- as.matrix(template)  \n      }\n      if (PEMnumgens > 3) {\n        # Pupal DOYs for when cumDDs > pupalEvent threshold  4th Gen\n        PEMp4 <- as.matrix(template)  \n      }\n    }\n    \n    if (mapA == 1 & adultEventDD) {\n      if (PEMnumgens > 0) {\n        # Adult DOYs for when cumDDs > adultEvent threshold OW generation\n        PEMa0 <- as.matrix(template)  \n        # Adult DOYs for when cumDDs > adultEvent threshold  1st Gen\n        PEMa1 <- as.matrix(template)  \n      }\n      if (PEMnumgens > 1) {\n        # Adult DOYs for when cumDDs > adultEvent threshold  2nd Gen\n        PEMa2 <- as.matrix(template)  \n      }\n      if (PEMnumgens > 2) {\n        # Adult DOYs for when cumDDs > adultEvent threshold  3rd Gen\n        PEMa3 <- as.matrix(template)  \n      }\n      if (PEMnumgens > 3) {\n        # Adult DOYs for when cumDDs > adultEvent threshold  4th Gen\n        PEMa4 <- as.matrix(template)  \n      }\n    }\n    \n  }\n  \n  #### * Step through days ####\n # tryCatch(\n  for (d in 1:length(sublist)) {\n    #cat(\"\\n\\ndoy: \", sublist[d], \"\\n\", file=daily_logFile, append=TRUE) \n    stage_dd_cohort <- stage_dd[as.integer(cohort), ]  \n    \n    # Get temperature matrices for the day\n    if (region_param %in% c(\"CONUS\", \"EAST\")) {\n      tmax <- as.numeric(tmax_list[[tile_num]][[d]])\n      tmin <- as.numeric(tmin_list[[tile_num]][[d]])\n    } else {\n      tmax <- as.numeric(tmax_list[[d]])\n      tmin <- as.numeric(tmin_list[[d]])\n    }\n    \n    # Assign each raster cell to a Lifestage\n    # These three matrices assign physiological parameters by cell\n    ls_ldt <- stage_ldt[Lifestage]\n    ls_udt <- stage_udt[Lifestage]\n    ls_dd <- stage_dd_cohort[Lifestage]\n    \n    # Calculate stage-specific degree-days for each cell per day\n    dd_tmp <- TriDD(tmax, tmin, ls_ldt, ls_udt)\n    \n    # Accumulate degree days\n    DDaccum <- DDaccum + dd_tmp\n    \n    # Accumulate total DDs across year, using larvae Lifestage\n    # Can not use DDaccum because this one has values reset when progress = 1\n    ls_ldt_larv <- stage_ldt[which(stgorder == \"L\")]\n    ls_udt_larv <- stage_udt[which(stgorder == \"L\")]\n    dd_tmp_larv <- TriDD(tmax, tmin, ls_ldt_larv, ls_udt_larv)\n    DDtotal <- DDtotal + dd_tmp_larv\n    \n    # Climate stress exclusions - results will be same for all cohorts, \n    # so just calculate exclusions for cohort 1\n    if (exclusions_stressunits) {\n      # Cold stress accumulation\n      # Make today's cold mask and calculate today's cold stress DDs\n      coldmask <- tmin < coldstressTHRESH  \n      coldstress <- coldmask * abs(coldstressTHRESH - tmin) \n      coldunitsCUM <- coldunitsCUM + coldstress\n      # ASSUME NEW -2=severe -1=mod 0=none throughout\n      coldEXCL <- Cond(coldunitsCUM >= coldstressMAX2, -2, \n                        Cond(coldunitsCUM >= coldstressMAX1, -1, 0))\n      # Heat stress accumulation\n      # Make today's heat mask and calculate today's heat stress DDs\n      heatmask <- tmax > heatstressTHRESH  \n      heatstress <- heatmask * abs(tmax - heatstressTHRESH) \n      heatunitsCUM <- heatunitsCUM + heatstress\n      heatEXCL <- Cond(heatunitsCUM >= heatstressMAX2, -2, \n                       Cond(heatunitsCUM >= heatstressMAX1, -1, 0))\n      AllEXCL <- Cond((coldEXCL == 0) & (heatEXCL == 0), 0,\n                      Cond((coldEXCL == -1) & (heatEXCL >= -1),-1,\n                           Cond((coldEXCL >= -1) & (heatEXCL == -1), -1, -2)))\n    }\n    \n    # Calculate pest events\n    # DOYs for when cumDDs > event threshold for a given generation\n    if (pems) {\n      \n     # The OW pest event is a percentage of the OW stage DDs \n     # (e.g. OWEventP = 0.5 would be 50% of the OWlarvaeDD, or half-way \n     # through OWlarvaeDD). It is specified in the species param file.\n      OWEventDD <- stage_dd_cohort[1] * OWEventP\n      \n      # Egg PEMs\n      if (mapE == 1 & eggEventDD) {  \n        if (PEMnumgens > 0) {\n          if (owstage == \"OE\") {\n          # If owstage = egg, then eggs finish developing after the DD of OWegg \n          # for that cohort (do NOT use OWeggDD from param file - this is for \n          # DDRP v2)\n          PEMe0 <- Cond(PEMe0 == 0 & NumGen == 0 & (DDaccum >= OWEventDD), \n                          d * (Lifestage == which(stgorder == \"OE\")), PEMe0)\n          }\n          # Egg DOYs for when cumDDs > eggEvent threshold 1st gen\n          PEMe1 <- Cond(PEMe1 == 0 & NumGen == 1 & (DDaccum >= eggEventDD), \n                        d * (Lifestage == which(stgorder == \"E\")), PEMe1) \n        }\n        if (PEMnumgens > 1) {\n          # Egg DOYs for when cumDDs > eggEvent threshold 2nd gen\n          PEMe2 <- Cond(PEMe2 == 0 & NumGen == 2 & (DDaccum >= eggEventDD), \n                        d * (Lifestage == which(stgorder == \"E\")), PEMe2)\n        }\n        if (PEMnumgens > 2) {\n          # Egg DOYs for when cumDDs > eggEvent threshold 3rd gen\n          PEMe3 <- Cond(PEMe3 == 0 & NumGen == 3 & (DDaccum >= eggEventDD), \n                        d * (Lifestage == which(stgorder == \"E\")), PEMe3) \n        }\n        if (PEMnumgens > 3) {\n          # Egg DOYs for when cumDDs > eggEvent threshold 4th gen\n          PEMe4 <- Cond(PEMe4 == 0 & NumGen == 4 & (DDaccum >= eggEventDD), \n                        d * (Lifestage == which(stgorder == \"E\")), PEMe4) \n        }\n      }\n      \n      # Larvae PEMs\n      if (mapL == 1 & larvaeEventDD) {\n        if (PEMnumgens > 0) {\n          if (owstage == \"OL\") {\n          # If owstage = larvae, then larvae finish developing after the DD of \n          # OWlarvae for that cohort (do NOT use OWlarvaeDD from species\n          # param file - this is for DDRP v2 only)\n            PEMl0 <- Cond(PEMl0 == 0 & NumGen == 0 & (DDaccum >= OWEventDD), \n                          d * (Lifestage == which(stgorder == \"OL\")), PEMl0) \n          # If owstage = egg, then larvae of this OW gen will have to go through \n          # full development \n          } else if (owstage %in% c(\"OE\")) {\n            PEMl0 <- Cond(PEMl0 == 0 & NumGen == 0 & (DDaccum >= larvaeEventDD), \n                          d * (Lifestage == which(stgorder == \"L\")), PEMl0) \n          }\n          # Larvae DOYs for when cumDDs > larvaeEvent threshold 1st gen\n          PEMl1 <- Cond(PEMl1 == 0 & NumGen == 1 & (DDaccum >= larvaeEventDD), \n                        d * (Lifestage == which(stgorder == \"L\")), PEMl1) \n        }\n        if (PEMnumgens > 1) {\n          # Larvae DOYs for when cumDDs > larvaeEvent threshold 2nd gen\n          PEMl2 <- Cond(PEMl2 == 0 & NumGen == 2 & (DDaccum >= larvaeEventDD), \n                        d * (Lifestage == which(stgorder == \"L\")), PEMl2) \n        }\n        if (PEMnumgens > 2) {\n          # Larvae DOYs for when cumDDs > larvaeEvent threshold 3rd gen\n          PEMl3 <- Cond(PEMl3 == 0 & NumGen == 3 & (DDaccum >= larvaeEventDD), \n                        d * (Lifestage == which(stgorder == \"L\")), PEMl3) \n        }\n        if (PEMnumgens > 3) {\n          # Larvae DOYs for when cumDDs > larvaeEvent threshold 4th gen\n          PEMl4 <- Cond(PEMl4 == 0 & NumGen == 4 & (DDaccum >= larvaeEventDD), \n                        d * (Lifestage == which(stgorder == \"L\")), PEMl4) \n         }\n      }\n      \n      # Pupae PEMs\n      if (mapP == 1 & pupaeEventDD) {\n        if (PEMnumgens > 0) {\n          if (owstage == \"OP\") {\n            # If owstage = pupae, then pupae finish developing after the DD of \n            # OWpupae for that cohort (do NOT use OWpupaeDD from species param \n            # file - this is for DDRP v2)\n            PEMp0 <- Cond(PEMp0 == 0 & NumGen == 0 & (DDaccum >= OWEventDD), \n                          d * (Lifestage == which(stgorder == \"OP\")), PEMp0)\n            } else if (owstage %in% c(\"OE\", \"OL\")) {\n            # If owstage = egg or larvae, then pupae of the OW gen will have to \n            # go through full development \n            PEMp0 <- Cond(PEMp0 == 0 & NumGen == 0 & (DDaccum >= pupaeEventDD), \n                          d * (Lifestage == which(stgorder == \"P\")), PEMp0) \n            }  \n          # Pupae DOYs for when cumDDs > pupaeEvent threshold 1st gen\n          PEMp1 <- Cond(PEMp1 == 0 & NumGen == 1 & (DDaccum >= pupaeEventDD), \n                        d * (Lifestage == which(stgorder == \"P\")), PEMp1) \n        }\n        if (PEMnumgens > 1) {\n          # Pupae DOYs for when cumDDs > pupaeEvent threshold 2nd gen\n          PEMp2 <- Cond(PEMp2 == 0 & NumGen == 2 & (DDaccum >= pupaeEventDD), \n                        d * (Lifestage == which(stgorder == \"P\")), PEMp2) \n        }\n        if (PEMnumgens > 2) {\n          # Pupae DOYs for when cumDDs > pupaeEvent threshold 3rd gen\n          PEMp3 <- Cond(PEMp3 == 0 & NumGen == 3 & (DDaccum >= pupaeEventDD), \n                        d * (Lifestage == which(stgorder == \"P\")), PEMp3) \n        }\n        if (PEMnumgens > 3) {\n          # Pupae DOYs for when cumDDs > pupaeEvent threshold 4th gen\n          PEMp4 <- Cond(PEMp4 == 0 & NumGen == 4 & (DDaccum >= pupaeEventDD), \n                        d * (Lifestage == which(stgorder == \"P\")), PEMp4) \n        }\n      }\n      \n      # Adult PEMs\n      if (mapA == 1 & adultEventDD) {\n        if (PEMnumgens > 0) {\n          if (owstage == \"OA\") {\n            # If owstage = adult, then adults finish developing after the DD of\n            # OWadult for that cohort (do NOT use OWadultDD from species param \n            # file - this is for DDRP v2)\n            PEMa0 <- Cond(PEMa0 == 0 & NumGen == 0 & (DDaccum >= OWEventDD), \n                          d * (Lifestage == which(stgorder == \"OA\")), PEMa0) \n            } else if (owstage %in% c(\"OL\", \"OP\")) {\n            # If owstage = larvae or pupae, then adults of the OW gen will \n            # have to go through full development \n            PEMa0 <- Cond(PEMa0 == 0 & NumGen == 0 & (DDaccum >= adultEventDD), \n                          d * (Lifestage == which(stgorder == \"A\")), PEMa0) \n            }\n          # Adult DOYs for when cumDDs > adultEvent threshold 1st gen\n          PEMa1 <- Cond(PEMa1 == 0 & NumGen == 1 & (DDaccum >= adultEventDD), \n                        d * (Lifestage == which(stgorder == \"A\")), PEMa1) \n        } \n        if (PEMnumgens > 1) {\n          # Adult DOYs for when cumDDs > adultEvent threshold 2nd gen\n          PEMa2 <- Cond(PEMa2 == 0 & NumGen == 2 & (DDaccum >= adultEventDD), \n                        d * (Lifestage == which(stgorder == \"A\")), PEMa2) \n        }\n        if (PEMnumgens > 2) {\n          # Adult DOYs for when cumDDs > adultEvent threshold 3rd gen\n          PEMa3 <- Cond(PEMa3 == 0 & NumGen == 3 & (DDaccum >= adultEventDD), \n                        d * (Lifestage == which(stgorder == \"A\")), PEMa3) \n        }\n        if (PEMnumgens > 3) {\n          # Adult DOYs for when cumDDs > adultEvent threshold 4th gen\n          PEMa4 <- Cond(PEMa4 == 0 & NumGen == 4 & (DDaccum >= adultEventDD), \n                        d * (Lifestage == which(stgorder == \"A\")), PEMa4) \n        }\n      }\n      \n    }\n    \n    # Calculate Lifestage progression: Is accumulation > Lifestage requirement \n    # (0 = FALSE, 1 = TRUE)? If species has obligate diapause, then don't \n    # allow it to progress past the 1st gen overwintering stage.\n    if (exists(\"obligate_diapause\")) {\n      if (obligate_diapause == 1) {\n        if (owstage == \"OL\") {\n          progress <- Cond(NumGen <= 1 & Lifestage != which(stgorder == \"L\"), \n                           as.integer(DDaccum >= ls_dd), 0)\n          } else if (owstage == \"OP\") {\n            progress <- Cond(NumGen <= 1 & Lifestage != which(stgorder == \"P\"), \n                             as.integer(DDaccum >= ls_dd), 0)\n          } else if (owstage == \"OA\") {\n            progress <- Cond(NumGen <= 1 & Lifestage != which(stgorder == \"A\"), \n                             as.integer(DDaccum >= ls_dd), 0)\n          } else if (owstage == \"OE\") {\n            progress <- Cond(NumGen <= 1 & Lifestage != which(stgorder == \"E\"), \n                             as.integer(DDaccum >= ls_dd), 0)\n        }\n      }\n    # If no obligate diapause, then there are no limits on no. of generations\n    } else {\n      progress <- as.integer(DDaccum >= ls_dd)\n    }\n    \n    # If reproductive adult stage progresses, then that cell has oviposition \n    # and the generation count increases. If species has OW adults, then need \n    # to change stage value to \"adult\" to allow NumGen to increase when it \n    # progresses. \"OA\" = 1, and \"adult\" = 5 for species with OW adults\n    if (owstage == \"OA\") {\n      Lifestage2 <- Lifestage\n      Lifestage2[Lifestage2 == 1] <- 5\n      NumGen <- NumGen + (progress == 1 & Lifestage2 == 5)\n    } else {\n      # Value for \"adult\" varies depending on OW stage\n      NumGen <- NumGen + (progress == 1 & Lifestage == which(stgorder == \"A\")) \n    }\n    #cat(\"No. gen (max): \", max(NumGen, na.rm=T), \"\\n\", file=daily_logFile, \n    #append=TRUE) \n    \n    # If progress is 1, then there is progression to the next life stage\n    Lifestage <- Lifestage + progress\n    \n    # Reset the DDaccum cells to zero for cells that progressed to next stage\n    DDaccum <- DDaccum - (progress * ls_dd)\n    #cat(\"DDaccum (max): \", max(DDaccum, na.rm=T), \"\\n\", file=daily_logFile, \n    #append=TRUE)\n    \n    # Reassign cells that progressed past end of stgorder to first non-OW stage\n    Lifestage <- Cond(Lifestage == (length(stgorder) + 1), 2, Lifestage)\n    #cat(\"Lifestage (max): \", max(Lifestage, na.rm=T), file=daily_logFile, \n    #append=TRUE)\n    \n    #### * Save data for certain days, specified by sampling frequency ####\n    # Data from last sampling day of year is also saved\n    if (sublist[d] %in% sample_pts) {\n      #cat(\"sampled\", sublist[d])\n      # Convert Lifestage and Numgen matrices to rasters and put into a brick\n      mat_list <- list(Lifestage, NumGen, DDtotal)\n      ext <- as.data.frame(as.matrix(extent(template)))\n      rast_list <- lapply(mat_list, Mat_to_rast, ext = ext, template = template)\n      names(rast_list) <- c(\"Lifestage_rast\", \"NumGen_rast\", \"DDtotal_rast\")\n      \n      #cat(\"\\n\\n### Adding layers to Lifestage brick for cohort\", cohort, \": \n      #doy =\", sublist[d], \"\\n\", file=daily_logFile, append=TRUE)\n      # Lifestage brick\n      if (!exists(\"Lifestage_brick\")) {\n        Lifestage_brick <- brick(rast_list$Lifestage_rast, crs = crs)\n      } else {\n        Lifestage_brick <- addLayer(Lifestage_brick, rast_list$Lifestage_rast)\n      }\n      \n      #cat(\"### Adding layers to NumGen brick for cohort\", cohort, \": doy =\", \n      #sublist[d], \"\\n\", file=daily_logFile, append=TRUE)\n      # NumGen brick\n      if (!exists(\"NumGen_brick\")) {\n        NumGen_brick <- brick(rast_list$NumGen_rast, crs = crs)\n      } else {\n        NumGen_brick <- addLayer(NumGen_brick, rast_list$NumGen_rast)\n      }\n      \n      # Only need to do DDtotal brick for a single cohort, because it will be \n      # the same across all cohorts\n      if (cohort == 1) {\n        #cat(\"### Adding layers to DDtotal brick for cohort\", cohort, \": doy =\",\n        # sublist[d], file=daily_logFile, append=TRUE)\n        if (!exists(\"DDtotal_brick\")) {\n          DDtotal_brick <- brick(rast_list$DDtotal_rast, crs = crs)\n        } else {\n          DDtotal_brick <- addLayer(DDtotal_brick, rast_list$DDtotal_rast)\n        }\n      }\n      \n      rm(rast_list) # Free up memory\n      \n      # If exclusions_stressunits = 1, then do the same thing for LifestageEXCL \n      # and NumGenEXCL, after they are calculated\n      if (exclusions_stressunits) {\n\n        # Do the same for cold/heat units and cold/heat exclusion, but just \n        # for cohort 1, because results will be same for all cohorts\n        if (cohort == 1) {\n          # Convert matrices to rasters and put them into a raster brick\n          mat_list3 <- list(coldunitsCUM, coldEXCL, heatunitsCUM,\n                            heatEXCL, AllEXCL)\n          ext <- as.data.frame(as.matrix(extent(template)))\n          rast_list3 <- lapply(mat_list3, Mat_to_rast, ext = ext, \n                               template = template)\n          names(rast_list3) <- c(\"coldunitsCUM_rast\", \"coldEXCL_rast\", \n            \"heatunitsCUM_rast\", \"heatEXCL_rast\", \"AllEXCL_rast\")\n          \n          #cat(\"\\n### Adding layers to Cold Stress Units brick for cohort\", \n          #cohort, \": doy =\", sublist[d], \"\\n\", file=daily_logFile, append=TRUE)\n          # Cold stress unit accumulation brick\n          if (!exists(\"coldunitsCUM_brick\")) {\n            coldunitsCUM_brick <- brick(rast_list3$coldunitsCUM_rast, \n                                         crs = crs)\n          } else {\n            coldunitsCUM_brick <- addLayer(coldunitsCUM_brick, \n                                            rast_list3$coldunitsCUM_rast)\n          }\n          \n          #cat(\"### Adding layers to Cold Stress Exclusion brick for cohort\", \n          #cohort, \": doy =\", sublist[d], \"\\n\", file=daily_logFile, append=TRUE)\n          # Cold stress exclusion brick\n          if (!exists(\"coldEXCL_brick\")) {\n            coldEXCL_brick <- brick(rast_list3$coldEXCL_rast, crs = crs)\n          } else {\n            coldEXCL_brick <- addLayer(coldEXCL_brick, \n                                        rast_list3$coldEXCL_rast)\n          }\n          \n          #cat(\"### Adding layers to Heat Stress Units brick for cohort\", \n          #cohort, \": doy =\", sublist[d], \"\\n\", file=daily_logFile, append=TRUE)\n          # Heat stress unit accumulation brick\n          if (!exists(\"heatunitsCUM_brick\")) {\n            heatunitsCUM_brick <- brick(rast_list3$heatunitsCUM_rast, crs = crs)\n          } else {\n            heatunitsCUM_brick <- addLayer(heatunitsCUM_brick, \n                                           rast_list3$heatunitsCUM_rast)\n          }\n          \n          #cat(\"### Adding layers to Heat Stress Exclusion brick for cohort\", \n          #cohort, \": doy =\", sublist[d], \"\\n\", file=daily_logFile, append=TRUE)\n          # Heat stress exclusion brick\n          if (!exists(\"heatEXCL_brick\")) {\n            heatEXCL_brick <- brick(rast_list3$heatEXCL_rast, crs = crs)\n          } else {\n            heatEXCL_brick <- addLayer(heatEXCL_brick, rast_list3$heatEXCL_rast)\n          }\n          \n          #cat(\"### Adding layers to All Stress Exclusion brick for cohort\",\n          # cohort, \": doy =\", sublist[d], file=daily_logFile, append=TRUE)\n          # All stress exclusion brick (cold stress + heat stress exclusions)\n          if (!exists(\"AllEXCL_brick\")) {\n            AllEXCL_brick <- brick(rast_list3$AllEXCL_rast, crs = crs)\n          } else {\n            AllEXCL_brick <- addLayer(AllEXCL_brick, rast_list3$AllEXCL_rast)\n          }\n          \n          rm(rast_list3) # Free up memory\n        }\n      }\n    }\n   }#,\n  # error = function(e) {\n  #     # Add error message to the error log file\n  #     write(toString(e), msg, append=TRUE)\n  # }\n  # )\n  \n  ### * Daily loop done - save raster bricks ###\n  # Save non-optional raster bricks = Lifestage and NumGen\n  SaveRaster(Lifestage_brick, cohort, tile_num, \"Lifestage\", \"INT1U\")\n  SaveRaster(NumGen_brick, cohort, tile_num, \"NumGen\", \"INT1U\")\n\n  # Save DDtotal brick (only for cohort 1)\n  if (cohort == 1) {\n    SaveRaster(DDtotal_brick, cohort, tile_num, \"DDtotal\", \"INT2S\")\n  }\n  \n  # Free up memory\n  rm(Lifestage_brick, NumGen_brick, DDtotal_brick)\n  \n  # If Pest Event Maps are specified (pems = 1), then convert PEM matrices \n  # to rasters and save them\n  if (pems) {\n    pem_list <- mget(ls(pattern = \"PEMe|PEMl|PEMp|PEMa\"))\n    # Convert each matrix in the list to a raster and save it\n    for (i in 1:length(pem_list)) {\n      pem_mat <- pem_list[[i]]\n      pem_rast <- Mat_to_rast(pem_mat, ext, template)\n      if (region_param %in% c(\"CONUS\", \"EAST\")) {\n        SaveRaster(pem_rast, cohort, tile_num, names(pem_list[i]), \"INT2U\")\n      } else {\n        SaveRaster(pem_rast, cohort, NA, names(pem_list[i]), \"INT2U\")\n      }\n    }\n  }\n  \n  rm(list = ls(pattern = \"PEM|pem_list|pem_rast\")) # Free up memory\n  \n  # If exclusions_stressunits = 1, then save stress unit and exclusions bricks\n  if (exclusions_stressunits) {\n\n    # Cold and heat stress unit and exclusion bricks will be the same for \n    # all cohorts, so take only 1st one\n    if (cohort == 1) {\n      stress_excl_brick_list <- c(coldunitsCUM_brick, coldEXCL_brick,\n        heatunitsCUM_brick, heatEXCL_brick, AllEXCL_brick)\n      names(stress_excl_brick_list) <- c(\"Cold_Stress_Units\", \n        \"Cold_Stress_Excl\", \"Heat_Stress_Units\", \"Heat_Stress_Excl\", \n        \"All_Stress_Excl\")\n      \n      # Save each raster brick product in the list\n      for (i in 1:length(stress_excl_brick_list)) {\n        brk <- stress_excl_brick_list[[i]]  \n        SaveRaster(brk, cohort, tile_num, \n                   paste0(names(stress_excl_brick_list[i])), \"INT2S\")\n      \n      }\n      \n      # Free up memory\n      rm(stress_excl_brick_list, coldunitsCUM_brick, coldEXCL_brick,\n         heatunitsCUM_brick, heatEXCL_brick, AllEXCL_brick) \n      \n    }\n    #cat(\"\\n### Finished climate exclusions and stress units raster output \n    #cohort\", cohort, \"###\\n\\n\", file = Model_rlogging, append=TRUE)\n  }\n  \n  # Remove .xml files generated w/ .tif files for certain raster bricks\n  # Haven't yet figured out a way to prevent these from being created. The\n  # only solution I have found is to change a GDAL setting.\n  delfiles <- dir(path = output_dir, pattern = \"*xml\")\n  suppressWarnings(file.remove(file.path = output_dir, delfiles))\n  gc() # Clear items from the environment - is this necessary?\n  \n}\n\n\n#### (11). Degree Day calculation methods #### \n# Equations used to calculate degree-days\n# tmax = max. temp. data; tmin = min. temp data; LDT = lower developmental \n# temperature threshold; UDT = upper developmental temperature threshold\n\n# Simple Mean Temp DD Calc method: ((tmean > LDT) * (tmean - LDT))\n# Same result as max((tmax + tmin)/2 - LDT,0), so no need for tmean PRISM data. \nSimpDD <- function(tmax, tmin,LDT) {\n  return(max((tmax + tmin)/2 - LDT,0))\n}\n\n# Averaging DD Calc method (max + min/2 - tlow) but with horizontal \n# (substitution) upper threshold:\nAvgDD <- function(tmax, tmin, LDT, UDT) {\n  return(Cond(tmax < LDT, 0, Cond(tmin > UDT, 0, \n                                  Cond(tmax > UDT, (UDT + tmin)/2 - LDT, \n                                       Cond((tmax + tmin)/2 - LDT < 0,0, \n                                            (tmax + tmin)/2 - LDT)))))\n}\n\n# Single triangle with upper threshold (Sevachurian et al. 1977) - \n# also a good substitution for the single sine method\nTriDD <- function(tmax, tmin, LDT, UDT) {\n  tmax <- Cond(tmax == tmin, tmax + 0.01, tmax)\n  Tmp1 = 6*((tmax - LDT)*(tmax - LDT))/(tmax - tmin)\n  Tmp2 = 6*((tmax - UDT)*(tmax - UDT))/(tmax - tmin)\n  Cond(tmax < LDT,0,\n       Cond(tmin >= UDT,UDT - LDT,\n            Cond((tmax < UDT) & (tmin <= LDT), Tmp1/12,\n                 Cond((tmin <= LDT) & (tmax >= UDT), (Tmp1 - Tmp2)/12,\n                      Cond((tmin > LDT) & (tmax >= UDT), \n                           6*(tmax + tmin - 2*LDT)/12 - (Tmp2/12),\n                           Cond((tmin > LDT) & (tmax < UDT), \n                                6*(tmax + tmin - 2*LDT)/12,0))))))\n} \n\n#### (12). ExtractBestPRISM: get best PRISM/NMME file from directory ####\n# Take .bil files from PRISM or NMME (= forecast_data) yearly directories \n# (= files). The function returns the best data for each day. If data are \n# from a leap year, then leap day data may be removed or kept (= keep_leap).\nExtractBestPRISM <- function(files, forecast_data, keep_leap) {\n  numsplits <- str_count(string = files[1], pattern = \"/\")\n  pfile <- str_split(string = files, pattern = coll(\"/\"), numsplits) %>% \n    purrr::map(numsplits)\n  qa <- str_split(string = pfile, pattern = coll(\"_\"), 6) %>% purrr::map(3) %>% \n    unlist()\n\n  # Extract dates - the dates will always be the largest number, so sort and\n  # then take first element of vector\n  dates <- regexpr(pattern = \"[0-9]{8}\", text = files)\n  df <- data.frame(dates = regmatches(files, dates),\n                   quality = substr(qa, start = 1, stop = 4),\n                   rownum = 1:length(qa))\n  \n  # Added to Tyson's version of this function - ability to choose PRISM vs. \n  # NMME for future dates\n  if (forecast_data == \"PRISM\") {\n    df <- mutate(df, rank = ifelse(quality == \"stab\", 1, \n                            ifelse(quality == \"prov\", 2, \n                            ifelse(quality == \"earl\", 3, \n                            ifelse(quality == \"10yr\", 4, \n                            ifelse(quality == \"30yr\", 5, \n                            ifelse(quality == \"nmme\", 6, NA)))))))\n  } else if (dat == \"NMME\") {\n    df <- mutate(df, rank = ifelse(quality == \"stab\", 1, \n                            ifelse(quality == \"prov\", 2, \n                            ifelse(quality == \"earl\", 3, \n                            ifelse(quality == \"nmme\", 4, \n                            ifelse(quality == \"10yr\", 5, \n                            ifelse(quality == \"30yr\", 6, NA)))))))\n  }\n\n  # Sorting backwards matches data hierarchy\n  # If PRISM, then stable > provisional > early > 10yr > 30yr > nmme\n  # If NMME, then stable > provisional > early > nmme > 10yr > 30yr\n  df2 <- df %>% group_by(dates) %>% \n    dplyr::filter(rank == min(rank)) %>%\n    dplyr::filter(1:n() == 1)\n\n  best <- files[df2$rownum]\n  dates <- regexpr(pattern = \"[0-9]{8}\", text = best)\n  \n  fileorder <- order(regmatches(best, dates))\n  files <- best[fileorder]\n  \n  # Remove leap day (2/29) if the start_year is not a leap year, or if it is \n  # a leap year but user wants it removed (keep_leap == 0). This doesn't apply \n  # if 30 yr average data or other non-specific year data are being used\n  # (in this case, start_year is non-numeric)\n  if (is.numeric(start_year)) {\n    if (start_year %% 4 != 0 | start_year %% 4 == 0 & keep_leap == 0) {\n      files <- files[!grepl(paste0(start_year, \"0229\"), files)]\n    }\n  }\n  \n  return(files)\n}\n\n#### (13). Mat_to_rast: matrix to raster conversion ####\n# Converts a matrix (= m) to a raster, which involves specifying the extent \n# (= ext) from the template (= template), setting the coordinate system, and \n# assigning it a spatial resolution (from the template)\nMat_to_rast <- function(m, ext, template) {\n  rast <- raster(m, xmn = ext[1,1], xmx = ext[1,2], \n                    ymn = ext[2,1], ymx = ext[2,2])\n  crs <- crs(template)\n  res(rast) <- res(template)\n  NAvalue(rast) <- NaN\n  return(rast)\n}\n\n#### (14). PlotMap: summary map plotting - main ####\n# A VERY large function that generates summary plots for all products generated\n# in the DDRP model run\n# r = raster input, d = date, lgd = legend title, outfl = outfile name\n# TO DO: clean up code - remove redundancies\nPlotMap <- function(r, d, titl, lgd, outfl) {\n  \n  # If data are in raster format, then convert to a data frame\n  if (grepl(\"NumGen|Adult_byGen|Adult_Excl1_byGen|Adult_Excl2_byGen|StageCount\", \n            outfl)) {\n    df <- r # data are already in a data frame\n  } else {\n    df <- ConvDF(r) # convert raster to data frame\n  }\n  \n  # Shift x and y grid cells by 1 grid interval (res = 0.0417) because for some\n  # reason the states boundary does not line up quite right\n  #df$x <- df$x + 0.0417\n  #df$y <- df$y + 0.0417\n  \n  # Format all labels used for the plot\n  sp <- paste0(fullname, \":\") # Species full name\n  dat <- as.character(format(strptime(d, format = \"%Y%m%d\"), \n                             format = \"%m/%d/%Y\")) # Date\n  titl_orig <- titl # Used for some log captions\n  \n  # Plot title - if it's not a PEM, then put sampling date in title\n  if (!grepl(\"Avg|Earliest\", outfl)) {\n    titl <- paste(titl, dat, sep = \" \")\n  }\n  \n  if (grepl(\"PEM\", outfl)) {\n    start_year <- strtrim(d, 4) # if using 30 yr data, need to trim other chars\n    titl <- paste(titl, start_year, sep = \" \")\n  }\n  \n  # Subtitle (same for all plots)\n  subtitl <- paste(\"Maps and modeling\",\n    format(Sys.Date(), \"%m/%d/%Y\"), str_wrap(\"by Oregon State University IPPC \n    USPEST.ORG and USDA-APHIS-PPQ; climate data from OSU PRISM Climate Group\",\n    width = 150))\n  \n  # Need to enforce a rule for wrapping title and subtitle on plot\n  # The title and subtitle go off of page for some states (VT...any else?)\n  if (asp > 1.55) {\n    titl_width <- 45\n    subtitl_width <- 55\n  } else if (asp >= 1.4 & asp < 1.55) {\n      titl_width <- 55\n      subtitl_width <- 65\n  } else {\n    titl_width <- 65\n    subtitl_width <- 75\n  }\n  \n  # Code for plots will vary depending on the product type, as specified below\n  #\n  #### * DDtotal ####\n  if (grepl(\"DDtotal\", outfl)) {\n    # Caption for log file\n    log_capt <- paste(\"- Number of accumulated degree-days on\", \n                         format(as.Date(d, \"%Y%m%d\"), \"%m/%d/%Y\"))\n    \n    # Create plot separately for rasters where all DDtotal values = 0  \n    if (all(df$value == 0)) {\n      df$value <- factor(df$value)\n      # If there are any non-zero values, then cut values into bins\n    } else {\n      df <- Cut_bins(df, 10)  \n      df$value <- factor(df$value, \n                         levels = unique(df$value[order(df$value_orig)]))\n\n    }\n    \n    p <- Base_map(df) +       \n      scale_fill_brewer(palette = \"Spectral\", direction = -1, \n                        name = paste0(lgd)) +\n      labs(title = str_wrap(paste(sp, titl), width = titl_width), \n            subtitle = str_wrap(paste(subtitl), width = subtitl_width)) +\n      theme_map(base_size = base_size) + \n      mytheme\n    \n    #### * Lifestage relative pop size ####\n  } else if (grepl(\"OWegg|OWlarvae|OWpupae|OWadult|Egg|Larvae|Pupae|Adult\",\n                   outfl) & !grepl(\"byGen\", outfl)) {\n    # Caption for log file\n    # TO DO: some log captions get placed in the wrong line because the \n    # function is run in parallel. Not sure why this is happening only for \n    # Lifestage and not other output types, but maybe because there are \n    # nested parallel processes.\n    log_capt <- paste(\"-\", titl_orig, \"on\", format(as.Date(d, \"%Y%m%d\"), \n                                                      \"%m/%d/%Y\"))\n    df$value_orig <- df$value # Keep original values for sorting later\n    \n    # If data include climate exclusions, then format accordingly\n    # Need to remove -2 and -1 values prior to binning values for plot\n    if (exclusions_stressunits) {\n      if (any(df$value_orig >= 0)) {\n        df2 <- Cut_bins2(dplyr::filter(df, !value < 0))\n \n        # Filter out climate stress exclusion values\n        excl_df <- df %>% dplyr::filter(value < 0) # Take only -2 and -1 values\n        excl_df$value_orig <- excl_df$value\n        excl_df <- mutate(excl_df, value = ifelse(value == -2, \"excl.-severe\", \n                      ifelse(value == -1, \"excl.-moderate\", value)))\n        \n        # Put exlcusion values and Lifestage rel. pop size (binned) values back\n        # together, then order by original values so plots in numerical order\n        df3 <- rbind(excl_df, df2) \n        df <- df3 # Rename data frame\n          \n        # If clim. exclusions masks out all non-zero values, then just plot \n        # climate stress exclusions\n      } else if (all(df$value_orig < 0)) {\n          df <- mutate(df, value = ifelse(value == -2, \"excl.-severe\", \n                                  ifelse(value == -1, \"excl.-moderate\", value)))\n      }\n      \n      # If stress values are missing in data, then add a row so the legend\n      # still shows the stress category (Excl1 = excl.-severe, Excl2 = \n      # excl.-severe and excl.-moderate). Otherwise just recode stress values.\n      if (grepl(\"Excl1\", outfl) & (!(-2 %in% df$value_orig))) {\n        df <- df %>% \n          add_row(value = \"excl.-severe\", x = NA, y = NA, value_orig = -2)\n      } else if (grepl(\"Excl2\", outfl)) {\n        if (!(-2 %in% df$value_orig)) {\n          df <- df %>% \n              add_row(value = \"excl.-severe\", x = NA, y = NA, value_orig = -2)\n          }\n          if (!(-1 %in% df$value_orig)) {\n            df <- df %>% \n              add_row(value = \"excl.-moderate\", x = NA, y = NA, value_orig = -1)\n          }\n        }\n   \n    # If there are no climate stress exclusions\n    } else {\n      df <- Cut_bins2(df)\n    }\n  \n    # Make legend color keys and assign colors\n    if (any(df$value_orig >= 0)) {\n      \n      # Generate the color key\n      col_key <- data.frame(cols = c(colorRampPalette(c(\"dodgerblue3\", \"yellow\", \n                                                        \"red3\"))(10)),\n                            value_low = seq(0, 90, 10),\n                            value_high = seq(10, 100, 10))\n      col_key <- col_key %>% \n        mutate(value = paste(value_low, value_high, sep = \"-\")) %>%\n        dplyr::select(cols, value)\n      \n      # Create \"fake\" data rows if data are missing any bins so that key always \n      # shows 10 bins (0-10, 10-20, 20-30, etc.). Only bins below the max value\n      # in data are kept.\n      missing <- col_key %>% dplyr::select(value) %>%\n        filter(!(value %in% df$value)) %>%\n        filter(value < max(df$value)) %>% \n        mutate(x = NA, y = NA,\n            value_orig = as.numeric(str_split_fixed(value, \"-\", 2)[,1], value))\n      df <- rbind(df, missing)\n      df$value <- factor(df$value, levels = \n                               unique(df$value[order(df$value_orig)]))\n      \n      # Need to add grayscale cols to color key if there are\n      # climate stress exclusions (grayscale colors)\n      if (exclusions_stressunits) {\n        if (any(df$value == \"excl.-moderate\")) {\n          col_key <- rbind(data.frame(cols = \"gray70\",\n                                      value = \"excl.-moderate\"), col_key)\n        }\n        if (any(df$value == \"excl.-severe\")) {\n          col_key <- rbind(data.frame(cols = \"gray30\",\n                                      value = \"excl.-severe\"), col_key)\n        }\n      }\n      \n      # If all values are <= 0, then just show climate exclusions (grayscale)\n    } else if (all(df$value_orig < 0)) {\n      col_key <- data.frame(cols = c(\"gray30\", \"gray70\", \"dodgerblue3\"), \n                            value = c(\"excl.-severe\", \"excl.-moderate\", \"0\"))\n      col_key <- semi_join(col_key, df, by = \"value\") # keep only vals in data\n    }\n    \n    # Convert legend color key to a vector and make the plot\n    cols <- setNames(as.character(col_key$cols), col_key$value)\n    \n    p <- Base_map(df) +       \n      scale_fill_manual(values = cols, name = paste0(lgd)) +\n      labs(title = str_wrap(paste(sp, titl), width = titl_width), \n           subtitle = str_wrap(subtitl, width = subtitl_width)) +\n      theme_map(base_size = base_size) + \n      mytheme\n\n    #### * Number of generations ####\n  } else if (grepl(\"NumGen|NumGen_Excl1|NumGen_Excl2\", outfl)) {\n    \n    # Caption for logging file\n    if (grepl(\"NumGen_Excl1|NumGen_Excl2\", outfl)) { \n      log_capt <- paste(\"-\", str_wrap(\"Number of gens. with climate stress excl. \n                                      on\", width = 80),\n                        format(as.Date(d, \"%Y%m%d\"), \"%m/%d/%Y\"))\n    } else {\n      log_capt <- paste(\"-\", \"Numbers of generations on\", \n                        format(as.Date(d, \"%Y%m%d\"), \"%m/%d/%Y\"))\n    }\n    \n    # Extract info on how many generations have been completed to date. This\n    # makes it possible to see all completed gens in the legend key even if \n    # they're not present on a given date.\n    if (any(df$value >= 0)) {\n      all_gens <- c(0:max(df$gen))\n      gens_df <- data.frame(\"value\" = paste(all_gens, \"gens.\"), \"x\" = NA, \n                          \"y\" = NA, \"gen\" = all_gens)\n    }\n    \n    # If only odd gens are plotted then need to remove even gens.\n    if (odd_gen_map == 1) {\n      gens_df <- gens_df %>% filter(gen %% 2 != 0)\n    }\n    \n    # Format values that are not climate stress exclusions (gen >= 0)\n    # Rel. pop sizes are grouped into 5 bins\n    df2 <- df %>% filter(value >= 0) %>% # Remove clim. stress values\n      mutate(value = ifelse(value < 20, 0, ifelse(value < 40, 20, \n                            ifelse(value < 60, 40, ifelse(value < 80, 60, \n                            ifelse(value < 100, 80, value))))),\n             value = paste(gen, \"gens.:\", value))\n    \n    if (any(df$value >= 0)) {\n      df2 <- rbind(df2, gens_df) # Add on all completed generations to date\n    }\n    \n    # Extract and back in climate stress exclusion values\n    excl_df <- df %>% dplyr::filter(value < 0) %>% \n      mutate(value = ifelse(value == -2, \"excl.-severe\", \n                                ifelse(value == -1, \"excl.-moderate\", value)))\n    df <- rbind(excl_df, df2)\n    \n    # If stress values are missing in data, then add a row (\"fake\" data)\n    # so the legend still shows the stress category (Excl1 = excl.-severe, \n    # Excl2 = excl.-severe and excl.-moderate).\n    if (grepl(\"Excl1\", outfl) & (!(\"excl.-severe\" %in% df$value))) {\n      df <- df %>% add_row(value = \"excl.-severe\", x = NA, y = NA, gen = -2)\n    } else if (grepl(\"Excl2\", outfl)) {\n      if (!(\"excl.-severe\" %in% df$value)) {\n        df <- df %>% add_row(value = \"excl.-severe\", x = NA, y = NA, gen = -2)\n      }\n      if (!(\"excl.-moderate\" %in% df$value)) {\n        df <- df %>% \n          add_row(value = \"excl.-moderate\", x = NA, y = NA, gen = -1)\n      }\n    }\n    \n    # Order by original values so plots in numerical order\n    df$value <- factor(df$value, \n                        levels = unique(df$value[order(df$gen)]))\n    \n    # Make the color key for the legend, rel. pop. size in bins of 20 (5 total)\n    # Currently enough colors for 20 generations\n    cols_df <- data.frame(\"cols\" = \n      c(Colfunc(\"deepskyblue\", \"blue3\", 5), # Gen 0 \n        Colfunc(\"orangered\", \"firebrick4\", 5), # Gen 1\n        Colfunc(\"yellow\", \"gold3\", 5), # Gen 2\n        Colfunc(\"lightgreen\", \"darkgreen\", 5), # Gen 3\n        Colfunc(\"magenta\", \"magenta4\", 5), # Gen 4\n        Colfunc(\"tan1\", \"darkorange3\", 5), # Gen 5\n        Colfunc(\"cyan\", \"cyan4\", 5), # Gen 6\n        Colfunc(\"greenyellow\", \"chartreuse4\", 5), # Gen 7\n        Colfunc(\"mediumpurple1\", \"purple3\", 5), # Gen 8\n        Colfunc(\"lightgoldenrod\", \"gold4\", 5), # Gen 9\n        Colfunc(\"cadetblue1\", \"cornflowerblue\", 5), # Gen 10\n        Colfunc(\"mistyrose\", \"palevioletred2\", 5), # Gen 11\n        Colfunc(\"seagreen1\", \"seagreen4\", 5), # Gen 12\n        Colfunc(\"lemonchiffon\", \"gold\", 5), # Gen 13\n        Colfunc(\"red\", \"darkred\", 5), # Gen 14\n        Colfunc(\"lightpink\", \"deeppink3\", 5), # Gen 15\n        Colfunc(\"lightgreen\", \"darkgreen\", 5), # Gen 16\n        Colfunc(\"sienna\", \"sienna4\", 5), # Gen 17\n        Colfunc(\"maroon1\", \"maroon4\", 5), # Gen 18\n        Colfunc(\"royalblue1\", \"royalblue4\", 5), # Gen 19\n        Colfunc(\"thistle1\", \"thistle4\", 5))) # Gen 20\n    bins_df <- data.frame(gen = c(rep(0, 5), rep(1, 5), rep(2, 5),\n        rep(3, 5), rep(4, 5), rep(5, 5), rep(6, 5), rep(7, 5), rep(8, 5), \n        rep(9, 5), rep(10, 5), rep(11, 5), rep(12, 5), rep(13, 5), rep(14, 5),\n        rep(15, 5), rep(16, 5), rep(17, 5), rep(18, 5), rep(19, 5), \n        rep(20, 5)))\n    col_key <- cbind(cols_df, bins_df) %>% \n      add_row(cols = c(\"gray70\", \"gray30\"), gen = c(-1, -2))\n\n    # Remove unneded colors, create bins of 5 to represent rel. pop. size. \n    # For legend, show only one color for each generation (map will have a \n    # gradation of this color). This is only done if there are values other\n    # than climate stress exclusions. The color for rel. pop. size = 60 is used.\n    # Add on a color for the \"other stages\" category (non-adult stages) - this\n    # is coded as -0.1 in order to properly sort it in the legend key.\n    if (any(df$gen >= 0)) {\n      col_key2 <- suppressWarnings(semi_join(col_key, df, by = \"gen\"))\n      num_gens <- length(unique(col_key2$gen)) # how many unique gens in data?\n      col_key2 <- col_key2 %>% \n        mutate(value = ifelse(gen >= 0, rep(c(0, 20, 40, 60, 80), \n                                          num_gens), gen), # 5 bins\n             value = ifelse(gen >= 0, paste(gen, \"gens.:\", value),\n                            ifelse(gen == -1, \"excl.-moderate\", \n                                   ifelse(gen == -2, \"excl.-severe\", NA))))\n      \n    # For legend, show only one color for each generation \n    # (map will have a gradation of this color)\n    lgnd_cols <- col_key2 %>% dplyr::filter(grepl(\": 60\", value))\n    lgnd_cols$value <- str_split_fixed(lgnd_cols$value, \n                                    pattern = \":\", 2)[,1] # Which gen?\n    col_key2 <- rbind(col_key2, lgnd_cols)\n    \n    # Breaks to use in plotting function, so only one shade per gen \n    # is shown in legend. Need to use str_sort so that the vector is sorted\n    # by generation number, not alphabetically.\n    lgnd_brks <- col_key2 %>% distinct(gen) %>% \n      arrange(gen) %>% \n      mutate(gen = ifelse(gen >= 0, paste(gen, \"gens.\"), \n                          ifelse(gen == -1, \"excl.-moderate\",\n                                 ifelse(gen == -2, \"excl.-severe\", gen)))) %>%\n      pull() # Convert to a vector\n\n    # If data only has climate stress values (no bins), create empty data\n    # frame for color key and populate based on stress values present in data.\n    } else {\n      col_key2 <- data.frame(cols = as.character(), value = as.character())\n      lgnd_brks <- df %>% arrange(gen) %>% distinct(value) %>% pull()\n      if (any(df$value == \"excl.-moderate\")) {\n        col_key2 <- col_key2 %>% \n          add_row(cols = \"gray70\", value = \"excl.-moderate\")\n      }\n      if (any(df$value == \"excl.-severe\")) {\n        col_key2 <- col_key2 %>% \n          add_row(cols = \"gray30\", value = \"excl.-severe\")\n      }\n      \n    }\n      \n    # Create lgd. color vector and plot\n    cols <- setNames(as.character(col_key2$cols), col_key2$value) \n    p <- Base_map(df) + \n      scale_fill_manual(values = cols, breaks = lgnd_brks, \n                        name = str_wrap(paste0(lgd), width = 15)) +\n      labs(title = str_wrap(paste(sp, titl), width = titl_width), \n           subtitle = str_wrap(subtitl, width = subtitl_width)) +\n      theme_map(base_size = base_size) + \n      mytheme\n     \n    #### * Stage count ####\n  } else if (grepl(\"StageCount\", outfl)) {\n    # Caption for logging file\n      if (grepl(\"StageCount_Excl1|StageCount_Excl2\", outfl)) { \n        log_capt <- paste(\"-\", \n          str_wrap(\"Stage count with climate stress excl. on\", width = 80),\n          format(as.Date(d, \"%Y%m%d\"), \"%m/%d/%Y\"))\n      } else {\n        log_capt <- paste(\"-\", \"Stage count on\", \n                             format(as.Date(d, \"%Y%m%d\"), \"%m/%d/%Y\"))\n      }    \n      \n    # Format data if there are climate stress exclusion values\n      if (exclusions_stressunits) {\n        df <- df %>% mutate(value = ifelse(value_orig == -2, \"excl.-severe\", \n                        ifelse(value_orig == -1, \"excl.-moderate\", value)))\n        \n        if (any(df$value_orig > 0)) {\n          # Need to remove -2 and -1 values prior to binning values for plot\n          df2 <- dplyr::filter(df, !value_orig < 0) \n          excl_df <- df %>% dplyr::filter(value_orig < 0) # Take only -2 and -1 \n          # Put exlcusion values and stage count values back together\n          df <- rbind(df2, excl_df) # Rename data frame\n        \n          # If clim. exclusions masks out all non-zero values, then just plot \n          # climate stress exclusions\n        } else if (all(df$value_orig <= 0)) {\n          df <- mutate(df, value = ifelse(value_orig == -2, \"excl.-severe\", \n                            ifelse(value_orig == -1, \"excl.-moderate\", value)))\n            \n        }\n        \n        # If stress values are missing in data, then add a row so the legend\n        # still shows the stress category (Excl1 = excl.-severe, Excl2 = \n        # excl.-severe and excl.-moderate). Otherwise just recode stress values.\n        if (grepl(\"StageCount_Excl1\", outfl) & (!(-2 %in% df$value_orig))) {\n          df <- df %>% \n            add_row(value = \"excl.-severe\", gen_stg = factor(-2))\n        } else if (grepl(\"StageCount_Excl2\", outfl)) {\n          if (!(-2 %in% df$value_orig)) {\n            df <- df %>% \n              add_row(value = \"excl.-severe\", gen_stg = factor(-2))\n          }\n          if (!(-1 %in% df$value_orig)) {\n            df <- df %>% \n              add_row(value = \"excl.-moderate\",  gen_stg = factor(-1))\n          }\n        }\n        df <- arrange(df, as.numeric(gen_stg))\n        sorted <- unique(as.numeric(df$gen_stg))\n      }\n      \n      # Define factor levels to order legend key properly\n      df$gen_stg <- factor(df$gen_stg, levels = sorted)\n      \n      # Make the color key for the legend \n      # Currently enough colors for 20 generations\n      cols_df <- data.frame(\"cols\" = \n        c(Colfunc(\"deepskyblue\", \"blue3\", 4), # Gen 0 \n          Colfunc(\"orangered\", \"firebrick4\", 4), # Gen 1\n          Colfunc(\"yellow\", \"gold3\", 4), # Gen 2\n          Colfunc(\"lightgreen\", \"darkgreen\", 4), # Gen 3\n          Colfunc(\"magenta\", \"magenta4\", 4), # Gen 4\n          Colfunc(\"tan1\", \"darkorange3\", 4), # Gen 5\n          Colfunc(\"cyan\", \"cyan4\", 4), # Gen 6\n          Colfunc(\"greenyellow\", \"chartreuse4\", 4), # Gen 7\n          Colfunc(\"mediumpurple1\", \"purple3\", 4), # Gen 8\n          Colfunc(\"lightgoldenrod\", \"gold4\", 4), # Gen 9\n          Colfunc(\"cadetblue1\", \"cornflowerblue\", 4), # Gen 10\n          Colfunc(\"mistyrose\", \"palevioletred2\", 4), # Gen 11\n          Colfunc(\"seagreen1\", \"seagreen4\", 4), # Gen 12\n          Colfunc(\"lemonchiffon\", \"gold\", 4), # Gen 13\n          Colfunc(\"red\", \"darkred\", 4), # Gen 14\n          Colfunc(\"lightpink\", \"deeppink3\", 4), # Gen 15\n          Colfunc(\"lightgreen\", \"darkgreen\", 4), # Gen 16\n          Colfunc(\"sienna\", \"sienna4\", 4), # Gen 17\n          Colfunc(\"maroon1\", \"maroon4\", 4), # Gen 18\n          Colfunc(\"royalblue1\", \"royalblue4\", 4), # Gen 19\n          Colfunc(\"thistle1\", \"thistle4\", 4))) # Gen 20\n        gens_df <- data.frame(gen = c(rep(1, 4), rep(2, 4),\n          rep(3, 4), rep(4, 4), rep(5, 4), rep(6, 4), rep(7, 4), rep(8, 4), \n          rep(9, 4), rep(10, 4), rep(11, 4), rep(12, 4), rep(13, 4), rep(14, 4),\n          rep(15, 4), rep(16, 4), rep(17, 4), rep(18, 4), rep(19, 4), \n          rep(20, 4)))\n        gens_df$gen <- sapply(gens_df$gen, function(x) {\n          paste(toOrdinal(x), \"gen.\") \n          })\n        gens_df <- rbind(data.frame(gen = c(rep(\"OW gen.\", 4))), gens_df)\n        \n        # Create the color key and named vector of the key\n        #col_key <- cols_df %>% mutate(gen_name = paste0(\"G\", gens_df$gen)) %>%\n        col_key <- cols_df %>% mutate(gen = gens_df$gen) %>%\n          mutate(stg_name = \n            rep_len(c(\"eggs\", \"larvae\", \"pupae\", \"adults\"), nrow(gens_df))) %>%\n          mutate(value = paste(gen, stg_name)) %>%\n          semi_join(., df, by = \"value\") %>%\n          dplyr::select(cols, value)\n        \n        # Order values by generationa nd life cycle stage order (i.e. egg, \n        # larvae, pupae, adult) or won't show up correctly in legend key\n        df$value <- factor(df$value, \n                  levels = unique(df$value[order(df$gen_stg)]))\n        \n        # Add grayscale colors to legend colors if climate stress exclusions\n        # Moderate stress exclusion\n        if (any(df$value == \"excl.-moderate\")) {\n          col_key <- rbind(data.frame(\"cols\" = \"gray70\", \n                                       \"value\" = \"excl.-moderate\"), col_key)\n        }\n        # Severe stress exclusions\n        if (any(df$value == \"excl.-severe\")) {\n          col_key <- rbind(data.frame(\"cols\" = \"gray30\", \n                                      \"value\" = \"excl.-severe\"), col_key)\n        }\n        \n      # Make the plot\n      cols <- setNames(as.character(col_key$cols), levels(df$value)) \n      p <- Base_map(df) + \n        scale_fill_manual(values = cols, \n                            name = str_wrap(paste0(lgd), width = 15)) +\n        labs(title = str_wrap(paste(sp, titl), width = titl_width), \n              subtitle = str_wrap(subtitl, width = subtitl_width)) +\n        theme_map(base_size = base_size) + \n        mytheme\n    \n     # Need to adjust number of rows in legend for very small plots or \n     # the legend will go off the page\n     if (asp < 0.5) {\n       p <- p + guides(fill = guide_legend(nrow = 15))\n     }\n      \n    #### * Climate stress exclusion maps ####\n  } else if (grepl(\"Heat_Stress_Excl|Cold_Stress_Excl|All_Stress_Excl\", \n                   outfl)) {\n    # Caption for log file\n    log_capt <- paste(\"-\", titl_orig, \n                  \"based on stress temperature thresholds and unit limits on\",\n                  format(as.Date(d, \"%Y%m%d\"), \"%m/%d/%Y\"))\n    # Re-assign values (0, -1, -2) to their corresponding description\n    df <- mutate(df, value = factor(ifelse(value == -2, \"excl.-severe\", \n                                    ifelse(value == -1, \"excl.-moderate\", \n                                    ifelse(value == 0, \"not excluded\",NA)))))    \n    df$value <- factor(df$value, levels = c(\"excl.-severe\", \"excl.-moderate\",\n                                           \"not excluded\")) # Order by values\n    # Make the plot\n    p <- Base_map(df) +        \n      scale_fill_manual(values = \n                          c(\"excl.-severe\" = \"gray30\",\n                            \"excl.-moderate\" = \"gray70\",\n                            \"not excluded\" = \"green2\"), name = paste0(lgd)) +\n      labs(title = str_wrap(paste(sp, titl), width = titl_width),\n           subtitle = str_wrap(subtitl, width = subtitl_width)) +\n      theme_map(base_size = base_size) + \n      mytheme + \n      theme(legend.text = element_text(size = rel(1.5)), \n            legend.title = element_text(size = rel(1.4), face = \"bold\"))\n      \n    #### * Lifestage w/ NumGen maps ####\n  } else if (grepl(\"Adult_byGen|Adult_Excl1_byGen|Adult_Excl2_byGen\", outfl)) {\n    # Caption for log file\n    log_capt <- paste(\"-\", \"Relative pop. size of adults for each gen. on\", \n                      format(as.Date(d, \"%Y%m%d\"), \"%m/%d/%Y\"))\n    \n    # Extract info on how many generations have been completed to date\n    all_gens <- c(0:max(df$gen))\n    gens_df <- data.frame(\"value\" = paste(all_gens, \"gens.\"), \n                          \"x\" = NA, \"y\" = NA, \"gen\" = all_gens)\n        \n    # If only odd gens are plotted then need to remove even gens.\n    if (odd_gen_map == 1) {\n      gens_df <- gens_df %>% filter(gen %% 2 != 0)\n    }\n    \n    # Create rows for previous generations so that they appear in the legend\n    # key even if they are absent on the sampling day\n    df <- df %>% mutate(gen = ifelse(value == -2, -2, \n                                     ifelse(value == -1, -1, gen)))\n    \n    # Format values that are not climate stress exclusions (gen >= 0)\n    df2 <- df %>% filter(gen >= 0) %>% # Remove clim. stress values\n      mutate(value = ifelse(value == 0, 0, # Create bins\n                            ifelse(value != 0 & value < 20, 1, \n                            ifelse(value < 40, 20, ifelse(value < 60, 40, \n                            ifelse(value < 80, 60, ifelse(value < 100, 80, \n                                   value))))))) %>%\n      mutate(value = paste(gen, \"gens.:\", value)) %>% \n      mutate(value = ifelse(grepl(\": 0\", value), \"other stages\", value))\n\n    df2 <- rbind(df2, gens_df) # Add on all completed generations to date\n        \n    # Extract and back in climate stress exclusion values\n    excl_df <- df %>% dplyr::filter(gen < 0) %>%  \n      mutate(value = ifelse(value == -2, \"excl.-severe\", \n                            ifelse(value == -1, \"excl.-moderate\", value)))\n    df <- rbind(excl_df, df2)\n      \n    # If stress values are missing in data (when climate stress exclusions \n    # are specified), then add a row (\"fake\" data) so the legend still shows \n    # the stress category (Excl1 = excl.-severe, \n    # Excl2 = excl.-severe and excl.-moderate).\n    if (grepl(\"Excl1\", outfl) & (!(\"excl.-severe\" %in% df$value))) {\n      df <- df %>% \n        add_row(value = \"excl.-severe\", x = NA, y = NA, gen = -2)\n    } else if (grepl(\"Excl2\", outfl)) {\n      if (!(\"excl.-severe\" %in% df$value)) {\n        df <- df %>% \n          add_row(value = \"excl.-severe\", x = NA, y = NA, gen = -2)\n      }\n      if (!(\"excl.-moderate\" %in% df$value)) {\n        df <- df %>% \n          add_row(value = \"excl.-moderate\", x = NA, y = NA, gen = -1)\n      }\n    }  \n    \n    # Order formatted values by original values so legend is in correct order\n    df$value <- factor(df$value, \n                       levels = unique(df$value[order(df$gen, df$value)]))\n    \n    # Make the color key for the legend \n    # Currently enough colors for 20 generations\n    cols_df <- data.frame(\"cols\" = \n      c(Colfunc(\"deepskyblue\", \"blue3\", 5), # Gen 0 \n        Colfunc(\"orangered\", \"firebrick4\", 5), # Gen 1\n        Colfunc(\"yellow\", \"gold3\", 5), # Gen 2\n        Colfunc(\"lightgreen\", \"darkgreen\", 5), # Gen 3\n        Colfunc(\"magenta\", \"magenta4\", 5), # Gen 4\n        Colfunc(\"tan1\", \"darkorange3\", 5), # Gen 5\n        Colfunc(\"cyan\", \"cyan4\", 5), # Gen 6\n        Colfunc(\"greenyellow\", \"chartreuse4\", 5), # Gen 7\n        Colfunc(\"mediumpurple1\", \"purple3\", 5), # Gen 8\n        Colfunc(\"lightgoldenrod\", \"gold4\", 5), # Gen 9\n        Colfunc(\"cadetblue1\", \"cornflowerblue\", 5), # Gen 10\n        Colfunc(\"mistyrose\", \"palevioletred2\", 5), # Gen 11\n        Colfunc(\"seagreen1\", \"seagreen4\", 5), # Gen 12\n        Colfunc(\"lemonchiffon\", \"gold\", 5), # Gen 13\n        Colfunc(\"red\", \"darkred\", 5), # Gen 14\n        Colfunc(\"lightpink\", \"deeppink3\", 5), # Gen 15\n        Colfunc(\"lightgreen\", \"darkgreen\", 5), # Gen 16\n        Colfunc(\"sienna\", \"sienna4\", 5), # Gen 17\n        Colfunc(\"maroon1\", \"maroon4\", 5), # Gen 18\n        Colfunc(\"royalblue1\", \"royalblue4\", 5), # Gen 19\n        Colfunc(\"thistle1\", \"thistle4\", 5))) # Gen 20    \n     bins_df <- data.frame(gen = c(rep(0, 5), rep(1, 5), rep(2, 5),\n        rep(3, 5), rep(4, 5), rep(5, 5), rep(6, 5), rep(7, 5), rep(8, 5), \n        rep(9, 5), rep(10, 5), rep(11, 5), rep(12, 5), rep(13, 5), rep(14, 5),\n        rep(15, 5), rep(16, 5), rep(17, 5), rep(18, 5), rep(19, 5), \n        rep(20, 5)))\n    col_key <- cbind(cols_df, bins_df) %>% \n      add_row(cols = c(\"gray70\", \"gray30\"), gen = c(-1, -2))\n        \n    # Remove unneded colors, create bins of 5 to represent rel. pop. size. \n    # For legend, show only one color for each generation (map will have a \n    # gradation of this color). This is only done if there are values other\n    # than climate stress exclusions. The color for rel. pop. size = 60 is used.\n    # Add on a color for the \"other stages\" category (non-adult stages) - this\n    # is coded as -0.1 in order to properly sort it in the legend key.\n    if (any(df$gen >= 0)) {\n      col_key2 <- semi_join(col_key, df, by = \"gen\") \n      num_gens <- length(unique(col_key2$gen)) # how many unique gens in data?\n      col_key2 <- col_key2 %>% \n        mutate(value = ifelse(gen >= 0, rep(c(1, 20, 40, 60, 80), \n                                            num_gens), gen), # 5 bins\n               value = ifelse(gen >= 0, paste(gen, \"gens.:\", value),\n                              ifelse(gen == -1, \"excl.-moderate\", \n                              ifelse(gen == -2, \"excl.-severe\", NA)))) %>%\n        add_row(cols = \"gray90\", gen = -0.1, value = \"other stages\")\n      col_key2$value <- factor(col_key2$value, \n                        levels = unique(col_key2$value[order(col_key2$gen)]))\n      \n      # For legend, show only one color for each generation \n      # (map will have a gradation of this color)\n      lgnd_cols <- col_key2 %>% dplyr::filter(grepl(\": 60\", value))\n      lgnd_cols$value <- str_split_fixed(lgnd_cols$value, pattern = \":\", 2)[,1]\n      \n      # Bind actual colors and legend colors together and create a \n      # named vector of these\n      col_key2 <- rbind(col_key2, lgnd_cols)\n      \n      # Breaks to use in plotting function, so only one shade per gen \n      # is shown in legend. Need to use str_sort so that the vector is sorted\n      # by generation number, not alphabetically.\n      lgnd_brks <- col_key2 %>% distinct(gen) %>% \n        arrange(gen) %>% \n        mutate(gen = ifelse(gen >= 0, paste(gen, \"gens.\"), \n                            ifelse(gen == -1, \"excl.-moderate\",\n                                   ifelse(gen == -2, \"excl.-severe\", \n                                          \"other stages\")))) %>%\n        pull() # Convert to a vector\n\n      # If data only has climate stress values (no bins), create empty data\n      # frame for color key and populate based on stress values present in data.\n      } else {\n        col_key2 <- data.frame(cols = as.character(), value = as.character())\n        lgnd_brks <- as.character(unique(df$value))\n        if (any(df$value == \"excl.-moderate\")) {\n          col_key2 <- col_key2 %>% \n              add_row(cols = \"gray70\", value = \"excl.-moderate\")\n        }\n        if (any(df$value == \"excl.-severe\")) {\n          col_key2 <- col_key2 %>% \n            add_row(cols = \"gray30\", value = \"excl.-severe\")\n        }\n      \n    }\n    \n    # Create lgd. color vector and plot\n    cols <- setNames(as.character(col_key2$cols), col_key2$value) \n    p <- Base_map(df) + \n      scale_fill_manual(values = cols, breaks = lgnd_brks, \n                        name = str_wrap(paste0(lgd), width = 15)) +\n      labs(title = str_wrap(paste(sp, titl), width = titl_width), \n           subtitle = str_wrap(subtitl, width = subtitl_width)) +\n      theme_map(base_size = base_size) + \n      mytheme\n\n    #### * Pest Event Maps ####\n  } else if (grepl(\"Avg|Earliest\", outfl)) {\n    log_capt <- paste(\"-\", titl_orig) # Caption for log file\n    start_year <- as.numeric(start_year)\n    \n    # Format the data value column\n    df <- df %>% \n      dplyr::filter(!(value %in% c(0, 366))) # remove day 0 and day 366\n    df$value <- round(df$value)\n    # TO DO: try to fix this so that don't end up with 6 weeks in Dec\n    # Currently must change value for day 364 and 365 to day 363, or end up w/\n    # 6 weeks in December for some years\n    df <- df %>% mutate(value = ifelse(value >= 364, 363, value))\n    df$value_orig <- df$value # Create for ordering recoded values later\n    \n    # Convert day of year to a date, convert date to a week of the year, and \n    # format to \"month-day\" format. First need to subtract 1 from all day of \n    # year values, because as.Date starts at day 1, not day 0\n    df$value <- df$value - 1\n    df$value <- as.Date(df$value, origin = \n                          as.Date(paste0(start_year, \"-01-01\"))) \n\n    # The resulting values may have dates before Jan-1 (Dec-30, Dec-31) because \n    # they occur in the same week as Jan-1. The ceiling_date function (dplyr)\n    # rounds up to the next month so that they begin on Jan-1 \n    # (e.g., 2019-12-31 == 2020-01-01)\n    df$value <- as.character(cut.POSIXt(strptime(df$value, format = \"%Y-%m-%d\"), \n                                        breaks = \"1 weeks\"))\n    badDates <- df %>% filter(grepl(as.character(start_year - 1), value))\n    badDates$value <- as.character(ceiling_date(as.Date(badDates$value, \n                                                format = \"%Y-%m-%d\"), \"month\"))\n    \n    # Now replace old data with data that have fixed date\n    # Then add week of month column\n    df <- df %>% filter(!(grepl(as.character(start_year - 1), value))) %>%\n      bind_rows(., badDates)    \n    df$week <- ceiling(mday(df$value)/7)\n    \n    # Reformat the dates to month-day (e.g., Jan-01, Jan-06, ...)\n    # Clim. exc. values (-1 and -2) will become NA\n    df$value <- format(strptime(df$value, format = \"%Y-%m-%d\"), \n                      format = \"%b-%d\")\n    \n    # Data frames w/ January may have 2 dates (Jan-01 + another) for week 1\n    # This will result in the key having 2 dates w/ same color\n    # Check to see if this is true, and if so, then add 1 week onto weeks for\n    # January\n    week1 <- df %>% filter(week == 1 & value_orig < 30) %>% distinct(value)\n    \n    if (nrow(week1) > 1) {\n      df <- df %>% \n        mutate(week = ifelse(grepl(\"Jan-\", value) & !grepl(\"Jan-01\", value), \n                             week + 1, week))\n    }\n    \n    # Generate a key for colors for every week of the year, allowing up to \n    # 5 weeks per month\n    cols_df <- data.frame(\"cols\" = \n      c(Colfunc(\"deepskyblue\", \"blue3\", 5),\n        Colfunc(\"red\", \"darkred\", 5), \n        Colfunc(\"yellow\", \"gold3\", 5),\n        Colfunc(\"lightgreen\", \"darkgreen\", 5), \n        Colfunc(\"magenta\", \"magenta4\", 5),\n        Colfunc(\"sienna1\", \"sienna4\", 5),\n        Colfunc(\"cyan\", \"cyan4\", 5),\n        Colfunc(\"greenyellow\", \"chartreuse4\", 5),\n        Colfunc(\"mediumpurple1\", \"purple3\", 5),\n        Colfunc(\"lightpink\", \"deeppink4\", 5),\n        Colfunc(\"lightgoldenrod\", \"gold4\", 5), \n        Colfunc(\"cadetblue1\", \"cornflowerblue\", 5))) # Colors\n    weeks_df <- data.frame(\"mnth\" = c(rep(\"Jan\", 5), rep(\"Feb\", 5), \n      rep(\"Mar\", 5), rep(\"Apr\", 5), rep(\"May\", 5), rep(\"Jun\", 5), rep(\"Jul\", 5),\n      rep(\"Aug\", 5), rep(\"Sep\", 5), rep(\"Oct\", 5), rep(\"Nov\", 5), \n      rep(\"Dec\", 5))) # 5 weeks per month\n    weeks_df <- data.frame(weeks_df %>% group_by(mnth) %>% # Group by month\n      mutate(mnth_wk = row_number()) %>% # Assign unique row # to rep. week #\n      mutate(mnth_wk = paste(mnth, mnth_wk, sep = \"_\")))\n    \n    # Attach those data frames to make the key\n    col_key <- cbind(cols_df, weeks_df)\n    col_key$mnth <- as.character(col_key$mnth) # Add which month\n    \n    # Extract all unique weeks from data,and count no. of bins (months)\n    dats <- df %>% distinct(value) \n    dats$mnth <- str_split_fixed(dats$value, pattern = \"-\", 2)[,1]\n    dats <- dats %>% arrange(., value) %>%\n      group_by(mnth) %>% # Group by month\n      # Assign a unique value to each row in a month - used for joining later\n      # This will also be done for other data frames below \n      \n      #mutate(week = ceiling(day(mnth_day) / 7)) %>%\n      left_join(dplyr::select(df, value, week), by = \"value\") %>%\n      mutate(mnth_day = format(as.Date(value, \"%b-%d\"))) %>%\n      mutate(mnth_wk = paste(mnth, week, sep = \"_\")) %>%\n      distinct(., .keep_all = TRUE) %>%\n      arrange(mnth_day)\n\n    # Necessary for removing weeks that are not in the data in the col_key2\n    mnth_ct <- data.frame(dats %>% group_by(mnth) %>% \n      dplyr::mutate(freq = n_distinct(value))) %>%\n      group_by(mnth) #%>% # Group by month\n\n    # Finally filter unncessary weeks out of generic color key (some months \n    # have only 4 weeks)\n    col_key2 <- dplyr::semi_join(col_key, dats, by = \"mnth\") %>% \n      dplyr::left_join(., mnth_ct, by = c(\"mnth_wk\")) %>%\n      na.omit %>%\n      dplyr::select(cols, value)\n    \n    # Format the dates dataframe (dats2) for joining to col_key2 (color key)\n    dats2 <- data.frame(dplyr::select(dats, value, mnth) %>% \n                          arrange(mnth, value))\n\n    # Attach the colors to the value and format with needed colunms, etc.\n    col_key2 <- left_join(col_key2, dplyr::select(dats2, -mnth), by = \"value\")\n    col_key2$year <- start_year\n    col_key2$date <- paste0(col_key2$year, \"-\", col_key2$value)\n    col_key2$date <- as.Date(col_key2$date, format = \"%Y-%b-%d\")\n    col_key2 <- col_key2 %>% dplyr::select(value, cols)\n\n    # If data have climate stress exclusion values, need to reformat data\n    # because values are non-dates; recode them, then bind back to original\n    # data. Finally add grayscale shades to the color key for legend.\n    if (any(df$value_orig < 0)) {\n      df2 <- filter(df, value_orig < 0)\n      df2 <- mutate(df2, value = ifelse(df2$value_orig == -2, \"excl.-sev.\", \n                                 ifelse(df2$value_orig == -1, \"excl.-mod.\", \n                                        df2$value)))\n      df3 <- rbind(filter(df, value_orig > 0), df2)\n      # Order according to orig. vals (DOY)\n      df3$value <- factor(df3$value, levels = \n        unique(df3$value[order(as.numeric(as.character(df3$value_orig)))]))\n      } else {\n      df3 <- df\n      df3$value <- factor(df3$value, levels = \n        unique(df3$value[order(as.numeric(as.character(df3$value_orig)))]))\n      }\n      if (any(df$value_orig == -1)) {\n        col_key2 <- rbind(data.frame(\"value\" = \"excl.-mod.\", \"cols\" = \"gray70\"), \n                          col_key2)\n      }\n      if (any(df$value_orig == -2)) {\n        col_key2 <- rbind(data.frame(\"value\" = \"excl.-sev.\", \"cols\" = \"gray30\"), \n                          col_key2)\n     }\n\n    # Make legend colors df a vector and plot results\n    cols <- setNames(as.character(col_key2$cols), col_key2$value)\n    p <- Base_map(df3) + \n      scale_fill_manual(values = cols, name = str_wrap(paste0(lgd), \n                                                       width = 15)) +\n      labs(title = str_wrap(paste(sp, titl), width = titl_width), \n           subtitle = str_wrap(paste(subtitl), width = subtitl_width)) +\n      theme_map(base_size = base_size) + \n      mytheme\n     \n     # Need to adjust number of rows in legend for small aspect plots or \n     # the legend will go off the page\n     if (asp < 0.6) {\n       p <- p + guides(fill = guide_legend(nrow = 15))\n     }\n     \n  }\n\n  #### * Save the plots ####\n  # Save the plot, or else report that there was an error and skip\n  # See \"rmessages.txt\" for error report\n  tryCatch(\n    {\n      suppressMessages(ggsave(p, file = paste0(outfl, \"_\", d, \".png\"), \n                              height = asp * 7, units = c('in'), dpi = 300))\n      cat(paste0(\"\\n\\nSaving summary map: \", outfl, \"_\", d, \".png\\n\"),  \n          str_wrap(paste0(log_capt, \"\\n\"), width = 80, exdent = 2), sep = \"\",\n          file = Model_rlogging, append = TRUE) # print progress in log file\n      # cat(\"\\n\\nSaving summary map: \", outfl, \"_\", d, \".png\\n\", sep = \"\", \n      #     file = Model_rlogging, append = TRUE) # print progress in log file\n      # cat(str_wrap(paste0(log_capt, \"\\n\"), width = 80, exdent = 2),\n      #     file = Model_rlogging, append = TRUE) # plot caption for log file\n    },\n    error = function(e) {\n      cat(\"\\nCould not create plot for \", outfl, \"_\", d, \".png\\n\", sep = \"\", \n          file = Model_rlogging, append = TRUE) \n    } )\n}\n\n#### (15). PlotMap_stress: summary map plotting - stress units ####\n# Create summary maps (PNG) of heat stress and cold stress units, \n# with max1 (Stress limit 1) and max2 (Stress limit 2) shown as \"countour\" lines\n# r = raster input; d = date; max1 = stress limit 1; max2 = stress limit 2;\n# titl = plot title; lgd = legend title; outfl = outfile name\nPlotMap_stress <- function(r, d, max1, max2, titl, lgd, outfl) {\n  log_capt <- paste(\"- Number of accumulated\", tolower(lgd), \"on\", \n                       format(as.Date(d, \"%Y%m%d\"), \"%m/%d/%Y\")) # Log file cap\n  sp <- paste0(gsub(pattern = \"_\", replacement = \" \", fullname), \":\")\n  dat <- as.character(format(strptime(d, format = \"%Y%m%d\"), \n                             format = \"%m/%d/%Y\"))\n  titl <- paste(titl, dat, sep = \" \")\n  subtitl <- paste(\"Maps and modeling\", format(Sys.Date(), \"%m/%d/%Y\"), \n    str_wrap(\"by Oregon State University IPPC USPEST.ORG and USDA-APHIS-PPQ; \n             climate data from OSU PRISM Climate Group\",  width = 150))  \n  df <- ConvDF(r)\n  df$value_orig <- df$value\n  df2 <- Stress_Val_Conv(df) # Properly formats values\n  \n  # Need to wrap title and subtitle for narrow plots (e.g., RI)\n  if (asp > 1.55) {\n    titl_width <- 45\n    subtitl_width <- 55\n  } else {\n    titl_width <- 55\n    subtitl_width <- 75\n  }\n  \n  # Create contours from raster values greater than limit 1 and limit 2, if \n  # raster values are greater than max1 and/or max2\n  max1_c <- tryCatch(\n    {\n      # max_1 is object of class \"SpatialLinesDataFrame\"\n      max1_c <- rasterToContour(r > max1) \n    },\n    error = function(e) {\n      max1_c <- 0 \n    } )\n  max2_c <- tryCatch(\n    {\n      # max_2 is object of class \"SpatialLinesDataFrame\"\n      max2_c <- rasterToContour(r > max2) \n    },\n    error = function(e) {\n      max2_c <- 0 \n    } )\n  \n  # If all values are 0 or are less than 10 (if stress limit < 10), then don't \n  # include contours (must include this code or it will throw an error)\n  if (all(df$value == 0 | all(df$value < 10 & all(df$value < max1)))) {\n    p <- Base_map(df2) +\n      scale_fill_manual(values = c(\"#5E4FA2\"), name = paste0(lgd)) +\n      labs(title = str_wrap(paste(sp, titl), width = titl_width), \n           subtitle = str_wrap(subtitl, width = subtitl_width)) +\n      theme_map(base_size = base_size) + \n      mytheme \n    \n    # If any values are greater than 0, but not greater than max1, then don't \n    # plot either countour (must include or it will thrown an error)\n  } else if (any(df$value > 0) & is.numeric(max1_c)) {\n    p <- Base_map(df2) +\n      scale_fill_brewer(palette = \"Spectral\", direction = -1, \n                        name = str_wrap(paste0(lgd), width = 15)) +\n      labs(title = str_wrap(paste(sp, titl), width = titl_width), \n           subtitle = str_wrap(subtitl, width = subtitl_width)) +\n      theme_map(base_size = base_size) + \n      mytheme\n    \n    # If any values are greater than limit 1 but less than limit 2, then \n    # plot countour line for just limit 1\n  } else if (any(df$value > 0) & !is.numeric(max1_c) & is.numeric(max2_c)) { \n    # max1_c is class \"SpatialLinesDataFrame\" but max2_c is class \"numeric\" \n    # (max2_c = 0)\n    p <- Base_map(df2) +\n      scale_fill_brewer(palette = \"Spectral\", direction = -1, \n                        name = str_wrap(paste0(lgd), width = 15)) +\n      scale_color_manual(name = \"Stress Limits\", \n                         values = c(\"Stress limit 1\" = \"magenta\")) +\n      geom_path(data = max1_c, aes(x = long, y = lat, group = group, \n                                   color = \"Stress limit 1\"), lwd = 0.15) +\n      labs(title = str_wrap(paste(sp, titl), width = titl_width), \n           subtitle = str_wrap(subtitl, width = subtitl_width)) +\n      theme_map(base_size = base_size) + \n      mytheme +\n      guides(colour = guide_legend(override.aes = list(size = 1), order = 1)) \n    \n    # If any values are greater than limit1 and limit2, then plot \n    # countour lines for both limit1 and limit2\n  } else if (!is.numeric(max1_c) & !is.numeric(max2_c)) {\n    p <- Base_map(df2) +\n      scale_fill_brewer(palette = \"Spectral\", direction = -1, \n                        name = str_wrap(paste0(lgd), width = 15)) +\n      scale_color_manual(name = \"Stress Limits\", \n                         values = c(\"Stress limit 1\" = \"magenta\", \n                                    \"Stress limit 2\" = \"mediumblue\")) +\n      geom_path(data = max1_c, aes(x = long, y = lat, group = group, \n                                   color = \"Stress limit 1\"), lwd = 0.15) +\n      geom_path(data = max2_c, aes(x = long, y = lat, group = group, \n                                   color = \"Stress limit 2\"), lwd = 0.15) +\n      labs(title = str_wrap(paste(sp, titl), width = titl_width), \n           subtitle = str_wrap(subtitl, width = subtitl_width)) +\n      theme_map(base_size = base_size) + \n      mytheme +\n      guides(colour = guide_legend(override.aes = list(size = 1), order = 1))\n  }\n  \n  # Save the plot, or else report that there was an error and skip - \n  # See \"rmessages.txt\" for error report\n  tryCatch(\n    {\n      ggsave(p, file = paste0(outfl, \"_\", d, \".png\"), height = 7 * asp, \n             units = c('in'), dpi = 200) \n      cat(\"\\n\\nSaving summary map: \", outfl, \"_\", d, \".png\\n\", \n          str_wrap(paste0(log_capt, \"\\n\"), width = 80), sep = \"\",\n          file = Model_rlogging, append = TRUE)\n    },\n    error = function(e) {\n      cat(\"Could not create plot for \", outfl, \"_\", d, \".png\\n\", sep = \"\", \n          file = Model_rlogging, append = TRUE) \n    } )\n}\n\n#### (16). Rast_Subs_Excl: lifestage raster weighting + clim. stress excl. ####\n# Substitutes weighted lifestage raster values with severe (-2) \n# and moderate (-1) climate stress exclusions (Excl2) in areas under climate \n# stress (i.e., where Lifestage overlaps with Excl2)\n# Two types: severe stress only (Excl1) or severe and moderate stress (Excl2)\nRast_Subs_Excl <- function(brk, type) {\n  \n  # Get all climate stress exclusion data\n  allEXCL_brk <- brick(list.files(pattern = glob2rx(\"*All_Stress_Excl*.tif$\")))\n  \n  # If PEM, then only take the last layer of allEXCL_brk (last date)\n  # because PEMs are created only for the last date\n  if (deparse(substitute(brk)) == \"PEM\") {\n    allEXCL_brk <- allEXCL_brk[[last(nlayers(allEXCL_brk))]] # Keep last layer\n  }\n  \n  # Identify pixels that have moderate (-1) or severe (-2) stress values.\n  # The corresponding pixel in the input raster brick will be replaced with a\n  # stress value. \n  lapply(1:nlayers(brk), function(lyr) {\n\n    # For each layer in the brick, get the corresponding layer\n    # in the All Stress Exclusion brick (allEXCL_brk)\n    brk_lyr <- brk[[lyr]]\n    Excl <- allEXCL_brk[[lyr]] \n    \n    # Replace pixels in brick layer with the stress values in\n    # areas of overlap\n    \n    if (type == \"Excl2\") {\n      Excl2 <- Excl < 0   # Both severe and moderate exclusion\n      brk_lyr[Excl2] <- Excl[Excl2] \n    } else if (type == \"Excl1\") {\n      Excl1 <- Excl == -2   # Only severe exclusion\n      brk_lyr[Excl1] <- Excl[Excl1]\n    }\n      \n    return(brk_lyr)\n  })\n  \n}\n\n#### (17). RegCluster: register cluster for parallel computing ####\n# Specifies the number of clusters to use for parallel computation. The \n# function will be different depending on the OS.\nRegCluster <- function(value) {\n  \n  # Change the value if it is 1 (this could happen if number of cores is low)\n  # Otherwise the whole process will not be run in parallel\n  if (value == 1) {\n    value <- 2\n  }\n  \n  if (grepl(\"Windows\", Sys.info()[1])) {\n    cl <<- makePSOCKcluster(value)\n  } else {\n    cl <<- makeCluster(value)\n  }\n  \n  # If run is being done on Hopper, need to specify the library for each worker\n  if (Sys.info()[\"nodename\"] == \"hopper.science.oregonstate.edu\") {\n    clusterEvalQ(cl, .libPaths(\"/usr/local/lib64/R/library/\"))\n  }\n  \n  doParallel::registerDoParallel(cl)\n  #on.exit(stopCluster(cl))\n  return(cl)\n}\n\n#### (18). SaveRaster: save rasters ####\n# Simply the \"writeRaster\" function from raster library but prints progress \n# in daily loop log file for a given cohort, if desired\n# r = raster, tile_num = tile number (only relevant to CONUS and EAST),\n# outnam = output file name; datatype = number of digits int the \n# output rasters (see \"raster\" library specificatoins)\nSaveRaster <- function(r, cohort, tile_num, outnam, datatype) {\n  if (region_param %in% c(\"CONUS\", \"EAST\")) {\n    #daily_logFile <- paste0(\"Daily_loop_cohort\", cohort, \"_\", tile_num, \".txt\")\n    writeRaster(r, file = paste0(outnam, \"_cohort\", cohort, \"_tile\", tile_num),\n                format = \"GTiff\",  datatype = datatype, overwrite = TRUE)\n  } else {\n    #daily_logFile <- paste0(\"Daily_loop_cohort\", cohort, \".txt\")\n    writeRaster(r, file = paste0(outnam, \"_cohort\", cohort), \n                format = \"GTiff\", datatype = datatype, overwrite = TRUE)\n  }\n  #cat(\"Saving raster: \", outnam, \"_cohort\", cohort, \".tif\\n\\n\", sep = \"\", \n  #file=daily_logFile, append=TRUE) \n}\n\n# Same as above but for saving rasters and raster bricks in the \n# \"Data Processing\" section, and prints caption in the log file\n# r = raster, outnam = output file name; datatype = number of digits int the \n# output rasters (see \"raster\" library specificatoins); log_capt = caption\nSaveRaster2 <- function(r, outnam, datatype, log_capt) {\n  writeRaster(r, file = outnam, format = \"GTiff\", datatype = datatype, \n              overwrite = TRUE)\n  if (nlayers(r) > 1) {\n    outnam2 <- paste0(\"\\n\\nSaving raster brick: \", outnam, \".tif\\n\")\n  } else {\n    outnam2 <- paste0(\"\\n\\nSaving raster: \", outnam, \".tif\\n\")\n  }\n  cat(outnam2, str_wrap(paste0(log_capt, \"\\n\"), width = 80, exdent = 2), \n      sep = \"\", file = Model_rlogging, append = TRUE) \n}\n\n#### (19). Stress_Val_Conv #### \n# Deal with 0 vs non-0 values when plotting cold and heat stress unit rasters\n# Only create bins (0-10, etc...) if there are non-zero values in the data \nStress_Val_Conv <- function(x) {\n  if (all(x$value == 0)) {\n    x2 <- x\n  } else {\n    x2 <- Cut_bins(x, 10)\n  }\n  # Need to fix bins if all data are < 10 \n  if (all(x2$value_orig < 10)) {\n    x2$value <- \"0-10\"\n  }\n  x2$value <- factor(x2$value, \n                     levels = unique(x2$value[order(x2$value_orig)]))\n  return(x2)\n}\n\n#### (20). SplitRas: split raster into tiles ####\n# The function spatially aggregates the original raster\n# from https://stackoverflow.com/questions/29784829/\n# r-raster-package-split-image-into-multiples\n# It turns each aggregated cell into a polygon, then the extent of each polygon \n# is used to crop the original raster. The function returns a list with all the \n# pieces in case you want to keep them in the memory. The arguments are:\n# raster = raster to be chopped            (raster object)\n# ppside = pieces per side                 (integer)\n# save   = write raster                    (TRUE or FALSE)\n# plot   = do you want to plot the output? (TRUE or FALSE)\nSplitRas <- function(raster, ppside, save, plot) {\n  h        <- ceiling(ncol(raster)/ppside)\n  v        <- ceiling(nrow(raster)/ppside)\n  agg      <- aggregate(raster, fact = c(h, v))\n  agg[]    <- 1:ncell(agg)\n  agg_poly <- rasterToPolygons(agg)\n  names(agg_poly) <- \"polis\"\n  r_list <- list()\n  for (i in 1:ncell(agg)) {\n    e1          <- extent(agg_poly[agg_poly$polis == i,])\n    r_list[[i]] <- crop(raster, e1)\n  }\n  if (save == TRUE) {\n    for (i in 1:length(r_list)) {\n      ii <- formatC(i, width = 2, format = \"d\", flag = \"0\")\n      writeRaster(r_list[[i]], filename = paste(\"SplitRas\", ii, sep = \"\"),\n                  format = \"GTiff\", datatype = \"FLT4S\", overwrite = TRUE)  \n    }\n  }\n  if (plot == TRUE) {\n    par(mfrow = c(ppside, ppside))\n    for (i in 1:length(r_list)) {\n      plot(r_list[[i]], axes = FALSE, legend = FALSE, bty = \"n\", box = FALSE)  \n    }\n  }\n  return(r_list)\n}\n\n#### (21). Weight_rasts: weight cohort rasters ####\n# Two input lists are required: 1) either \"Lifestage\" or \"NumGen\" raster bricks\n# for all cohorts, and 2) a vector of the relative population size comprised\n# by each cohort. The function weights the cohort bricks according the size. \n# If there are 7 cohorts sampled each month of yr (12 mon + end of year), \n# then rast_wtd will be a list of 7 cohorts each w/ 13 layers \n# (13 * 7 = 91 layers). \n\n# Weight the cohorts according to their relative size in the population, \n# exporting each generation as a single brick file\n# \"type\" variable will be life stage (stg) or generation number (gen)\n# \"value\" variable is not needed for the function to work; could remove\n# (stage number is in global environment), so maybe remove.\nWeight_rasts <- function(cohort_fls, fl_type) { \n  \n  # For each life stage or generation, extract data from raster brick, and \n  # multiple it by the rel. pop size of each cohort. The result is a list of \n  # raster bricks that provide the relative pop. size of each cohort for each \n  # date.\n  if (fl_type == \"Lifestage\") {\n    \n    # Function to recode results from the OW stage (stg_num = 1) to the same \n    # value as the non-OW stage, and then calculate the rel. pop. size of the\n    # combined stages (e.g., \"Adult\" size + \"OWadult\" size)\n\n      wtd_brk_lst <- list()\n      i <- 1\n      for (j in 1:length(cohort_fls)) {\n        \n        brk <- brick(cohort_fls[[j]])\n        \n        if (stg == stg_nonOW) {\n          brk[brk == 1] <- stg_num\n        }\n        \n        brk_stg <- brk == stg_num\n        wtd_brk <- round(100 * brk_stg) * relpopsize[i]\n        wtd_brk_lst[[j]] <- wtd_brk\n        i <- i + 1\n\n      }\n \n    # Same as analysis as above but according to generation\n  } else if (fl_type == \"NumGen\") {\n\n    wtd_brk_lst <- list()\n    i <- 1\n    for (j in 1:length(cohort_fls)) {\n    \n      brk <- brick(cohort_fls[[j]])\n      wtd_brk <- round(100 * brk) * relpopsize[i]\n      wtd_brk_lst[[j]] <- wtd_brk\n      i <- i + 1\n    \n    }\n  }\n    \n  # The results from previous step need to be summed across all cohorts. \n  # This produces a single raster brick in which each layer represents the \n  # relative population size of each cohort for each date.\n  # \"Reduce\" accomplishes this task.\n  wtd_sum <- Reduce(\"+\", wtd_brk_lst)\n  #gc()\n  \n  return(wtd_sum)\n}\n",
    "created" : 1597087991974.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2324233951",
    "id" : "B7F5EF00",
    "lastKnownWriteTime" : 1595476548,
    "last_content_update" : 1595476548,
    "path" : "/usr/local/dds/DDRP_B1/DDRP_v2_funcs.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}